# 5. 지속적 통합, 테스팅, 배포
## 1. 버전 관리

- ci/cd pipeline은 버전 관리가 중요
- k8s manifest, helm chart로 애플리케이션 코드 + 구성 코드가 함께 있어야 완전한 데브옵스 정착 가능

## 2. 지속적 통합

- CI: 코드 변경분을 버전 관리 리포지토리로 계속 통합하는 프로세스

## 3. 테스팅

- 코드베이스를 테스트하고 프로덕션에 전달하려면 팀 간 협력이 필요하며 엔드-투-엔드로 구현해야 함
    - helm chart의 엔드-투-엔드 테스트 → helm lint사용하자

## 4. 컨테이너 빌드

- 이미지를 빌드할 때 이미지 사이즈를 최적화 해야 함
- 멀티스테이지 빌드
    - 애플리케이션 실행에 불필요한 디펜던시 제거
- 무배포 베이스 이미지
    - 바이너리와 셸 삭제 → 이미지 사이즈가 작고 보안성이 좋음
- 최적화된 베이스 이미지
    - os layer에서 불필요한 부분을 잘라낸 이미지

## 5. 컨테이너 이미지 태깅

- tag에 latest를 붙이는건 비추
- 태깅 전략 →빌드 ID, 시스템-빌드 ID, 깃 해시, 깃 해비-빌드ID

## 6. 지속적 배포

- 쿠버네티스는 일관되게 버전을 관리하고 배포하는 선언형 방식으로 디플로이먼트 오브젝트를 기술함 → 일관된 환경 유지하기 편리함

## 7. 배포 전략

- 롤링 업데이트
    - 쿠버네티스에 내장된 기본 롤아웃 전략
    - 다운타임 없이 현재 실행 중인 애플리케이션에 업데이트 트리거 → readiness probe, life-cycle hook 필요
- 블루/그린 배포
    - 애플리케이션을 예측 가능한 방향으로 릴리스 가능
    - 옛 환경 + 새 환경을 동시에 배포할 만큼 충분한 용량이 필요
- 카나리 배포
    - 블루/그린과 유사하지만 새 릴리스로 트래픽을 넘기는 부분을 정교하게 제어할 수 있음
    - istio, 링커드, 해시코프 콘술로 서비스 메시 구현 가능
    - 일부에 대한 테스트 가능

## 8. 프로덕션 테스팅

- 카오스 엔지니어링: 라이브 프로덕션 시스템에 실험본을 배포해서 시스템 내의 취약성을 발견하는 방식
    
    → 애플리케이션의 회복 탄력성, 확장성, ux에 확신을 심어 줌
    

## 9. CI/CD 모범 사례

- ci → 자동화와 신속한 빌드에 집중하기
- 파이프라인에 안정적인 테스트 구축하기
- ci/cd 툴을 결정할 때는 파이프라인을 코드로 정의할 수 있는지 확인하기
- 이미지 사이즈는 가급적 줄이고 보안 취약점을 줄이기 위해 이미지를 최적화 하기
- 이미지 태그에 latest는 지양하기
- cd 단계에서 클라이언트가 애플리케이션에 어떻게 연결되는지, 데이터베이스 스키마 업그레이드는 어떻게 처리되는지 테스트 하기
- 프로덕션 테스팅을 소규모로 진행하기 + 환경 제한하기

# 6. 버저닝, 릴리스, 롤아웃
## 1. 버저닝

- 패턴 선택 + 유지
- 시맨틱 버저닝: 메이저 버전, 마이너 버전, 패치로 이루어짐
    - 패치: 버그 수정이나 Api 변경이 없는 아주 사소한 변경
    - 마이너 버전: api는 변경되었지만 이전 버전과 하위호환되는 업데이트

## 2. 릴리스

- deployment의 metadata.labels나 pod.spec.templatme.metadata.label스펙에 릴리스 정보 추가하기
- 버저닝을 일관되게 수행하고 클러스터 시스템 전반에 걸쳐 일관성을 지키는 것이 가장 중요함
- 레이블 셀렉터는 한번 생성되면 변경 x → 새로운 셀렉터를 추가하고, 매칭되는 파드 레이블이 있다면 새로운 레플리카셋이 생성됨(기존 레플리카셋으로 업데이트 되는건 아님)

## 3. 롤아웃

- 디플로이먼트 컨트롤러로 업데이트 프로세스를 특정한 전략으로 자동화
- spec.template변경 → 디플로이먼트 컨트롤러가 스펙 변경 감지 → 전략에 맞게 디플로이먼트 업데이트
- rollingUpadate: 디플로이먼트로 새 레플리카셋을 만들어 필요한 레플리카 수만큼 스케일-업하고 이전 레플리카셋은 maxUnavailable, masSurge값에 따라 스케일-다운
- recreate: 서비스 성능을 떨어뜨리지 않고 레플리카셋의 모든 파드를 완전 중단시킬 수 있는 워크로드에서 효과적인 전략 → 큐 기반 시스템에서 효과적

## 4. 모범 사례

- 컨테이너 + 전체 애플리케이션 자체의 라이프 사이클을 독립적으로 관리하려면 시맨틱 버저닝이 필수
    
    → 한 컨테이너가 다른 컨테이너를 변경할 때 계층형 방식으로 접근하면 추적하기 수월함
    
- 디플로이먼트 메타데이터에서 릴리스 네임과 릴리스 버전/번호 레이블을 사용하여 CI/CD 파이프라인 릴리스를 추적하기
- 함께 롤백하거나 업그레이드 할 서비스는 동일한 helm chart로 묶기
- 조직의 운영 템포에 알맞은 릴리스 네이밍 규칙 정하기 → stable, canary, alpha 정도
