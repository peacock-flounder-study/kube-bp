# Chapter 5. 지속적 통합, 테스팅, 배포

## 버전 관리

쿠버네티스 매니페스트나 헬름 차트처럼 애플리케이션 코드와 구성 코드가 함께 있어야 원활한 소통과 협업이라는 데브옵스 사상을 정착시킬 수 있다.

## 지속적 통합

운영팀 역시 애플리케이션 코드, 소프트웨어 개발 워크플로와 점차 가까워지고 있다.

## 테스팅

코드베이스 곳곳에서 자동화된 테스트를 실행할 수단을 궁리해야 한다.

## 컨테이너 빌드

이미지를 빌드할 때 이미지 사이즈를 최적화해야 한다.

사이즈가 작을수록 이미지를 가져와 배포하는 시간이 줄고 이미지 보안성이 좋아지기 때문이다.

- 멀티스테이지(다단계) 빌드
- 무배포(distroless) 베이스 이미지 : 불필요한 ㅂ아ㅣ너리와 셸을 이미지에서 제거
- 최적화된 베이스 이미지 : Alpine은 10MB에 불과한 용량의 베이스 이미지.

이미지 최적화는 정말 중요한 일인데 유저들은 이를 가볍게 생각하는 경향이 있다.

## 컨테이너 이미지 태깅

latest는 이미지 태그로 절대 사용 금지. 이 문자열만으로는 이미지에 어떤 코드 변경 내용이 포함됐는지 알 수 없다.

- 빌드 ID
- 시스템-빌드 ID
- Git Hash
- Git Gash-Build ID -> 태그가 꽤 길어질 수도 있다

## 지속적 배포

컨테이너 이미지는 개발, 스테이징을 거쳐 프로덕션으로 승격되는 불변(Immutable) 오브젝트다.

환경마다 라이브러리와 컴포넌트 버전이 달라지는 구성 드리프트 때문에 생긴다.

## 배포 전략

- 롤릴 업데이트 : 클라이언트와 커넥션이 끊어질 수 있으며, Rediness Probe와 preStop life-cycle hook(for connection draining)이 필요하다.
- 블루/그린 배포 : 장점 이면에 조심해야 할 점이 많음. Istio, linkerd, consul과 같은 서비스 메시 쓰면 유연하게.
- 카나리 배포 : 일부 유저에 한하여 신규 기능 테스트. A/B Release, Dark release. 새 릴리스가 steady state인지 어떻게 확신할 것인가?

## 프로덕션 테스팅

프로덕션 테스팅 효과를 식별할 수 있는 관찰 가능성 정략과 자동 복구할 수 있는 높은 수준의 자동화가 필요하다.

Tools : **traffic shadowing**

# Chapter 6. 버저닝, 릴리스, 롤아웃

새 코드를 빠르게 이터레이션하여 새로운 문제를 해결하고, 프로덕션에서 심각한 이슈가 터지기 전에 예방하면서 무중단 업그레이드를 보장하고 싶다!

## 버저닝

Semantic Versioning : Major.Minor.Patch

## 릴리스

디플로이먼트의 matadata.label이나 pod.spec.template.metadata.abel 스펙에 릴리스 정보를 추가한다.

버저닝을 일관되게 수행하고 클러스터 시스템 전반에 걸쳐 일관성을 지키는 것이 가장 중요하다.

**레이블 셀렉터는 한 번 생성되면 절대로 변경할 수 없으므로 새로운 셀렉터를 추가하고 여기에 매치되는 파드 레이블이 있으면 기존 레플리카셋으로 업데이트 되는 것의 아니라 새로운 레플리카 셋이 생성된다(!)**

## 롤아웃

디플로이먼트는 spec 변경을 감지하여 업데이트.

기본적으로 rollingUpdate 전략이 디폴트. 이전 레플리카셋은 maxUnavailable, maxSurge 값에 따라 스케일 다운. 언제든지 이전 버전으로 롤백 가능.

recreate는 새 레플리카셋을 만들고 새 파드를 온라인 상태로 전환하기 전에 이전 레플리카셋을 통째로 삭제한다. (전면 중단)

## BP

헬름으로 패키징할 경우, 함께 롤백하거나 업그레이드할 서비스는 동일한 헬름 차트로 묶어야 한다.

 
