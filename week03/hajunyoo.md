



----------------------------
# CH6. 버전, 릴리스, 롤아웃 완벽 가이드

'어떻게 애플리케이션을 안전하고 빠르게 업데이트할 것인가'

- 과거의 전통적인 애플리케이션(모놀리식)은 시간이 지나면서 너무 거대해져, 비즈니스가 요구하는 속도에 맞춰 업그레이드하기가 매우 어려웠음

오늘날 쿠버네티스와 함께하는 현대적인 개발의 목표는 명확

- 바로 '다운타임 없는 업그레이드(zero-downtime upgrades)'와 신속한 기능 반복을 달성하는 것.
- **버전 관리(Versioning), 릴리스(Release), 롤아웃(Rollout)**를 통해 수행

### '버전 관리'

소프트웨어 버전 관리는 특정 시점의 코드 상태를 식별하는 고유한 번호나 이름을 부여하는 프로세스. 

특히 여러 서비스가 서로 통신하는 마이크로서비스 아키텍처에서는 **시맨틱 버전 관리(Semantic Versioning)** 방식이 가장 유용

시맨틱 버전 관리는 `주.부.패치 (Major.Minor.Patch)`라는 세 부분으로 구성된 숫자 체계를 사용. 

각 부분은 다음과 같은 명확한 의미를 가지게 됨

| 구성요소 | 의미 | 변경되는 경우의 예시 |
| --- | --- | --- |
| **주 (Major)** | 이전 버전과 호환되지 않는 큰 변경 | API 호환성이 깨지는 대대적인 코드 수정 |
| **부 (Minor)** | 이전 버전과 호환되는 새로운 기능 추가 | 새로운 API 기능이 추가되었지만, 기존 기능은 그대로 작동 |
| **패치 (Patch)** | 이전 버전과 호환되는 버그 수정 | API 변경 없이 기존 코드의 버그를 해결 |

마이크로서비스 환경에서 시맨틱 버전 관리가 중요한 이유는, 개발자가 다른 서비스의 코드를 직접 보지 않고도 **버전 번호만으로 업데이트가 자신의 서비스에 미칠 영향을 예측**할 수 있게 해주기 때문. 

- eg. 부(Minor) 버전 업데이트는 기존 기능을 망가뜨리지 않을 것이라는 신뢰를 줌.
- 이는 시스템 전체의 안정성을 유지하는 데 매우 중요

### ‘Release'는 어떻게 버전을 관리하나

'무엇'을 업데이트할지(버전) 정의했으니, 실제로 '어떻게' 배포하고 관리할지에 대한 내용

쿠버네티스는 자체적으로 '릴리스(Release)'라는 개념을 가진 객체나 컨트롤러를 내장 X. Deployment와 같은 리소스의 메타데이터 레이블을 사용하여 릴리스를 식별하고 관리.

- 이 레이블은 Deployment의 최상단 `metadata.labels`에 추가될 수도 있고, 파드 템플릿 영역인 `spec.template.metadata.labels`에 추가될 수도 있음. 이 위치 선택은 '롤아웃'이 어떻게 트리거되는지에 중요한 영향을 미치므로 신중해야함
- 가장 대표적인 예는 헬름(Helm)
    - 헬름은 쿠버네티스 패키지 관리 도구로, 동일한 애플리케이션(차트)의 여러 실행 인스턴스를 구별하기 위해 공식적으로 '릴리스'라는 개념을 도입.
- 릴리스 이름은 특정 버전이 클러스터 내에서 어떤 역할을 하는지 명확히 알려주는 human friendly한 식별자 역할을 함. 일반적으로 다음과 같은 이름들이 사용됨
    - 조직의 운영 템포에 맞는 알맞은 릴리스 네이밍 컨벤션 정하자
    - `stable`: 안정화된 버전으로, 실제 사용자들에게 서비스되는 버전
    - `canary`: 새로운 기능을 소수의 사용자에게 먼저 공개하여 테스트하는 버전
    - `alpha`: 내부 개발 및 테스트 단계에 있는 버전

요약

- '릴리스'는 특정 **버전**의 애플리케이션이 클러스터에 배포된 **실행 인스턴스**에 붙이는 이름표와 같음.
    - 이름표 덕분에 우리는 지속적인 배포(CD) 파이프라인에서 어떤 버전이 어디서 실행 중인지 명확하게 추적하고 관리 가능

### '롤아웃'이 애플리케이션을 업데이트하는 방식

버전을 만들고 릴리스로 포장했다면, 이제 마지막 단계인 실제 배포 프로세스인 Rollout

'롤아웃(Rollout)'은 쿠버네티스의 Deployment 컨트롤러가 애플리케이션의 현재 상태를 의도한 새로운 상태로 업데이트하는 자동화된 프로세스를 의미

Deployment 업데이트는 `metadata` 섹션의 레이블을 변경한다고 해서 트리거 X 

- 오직 **`spec.template` 필드의 내용이 변경되었을 때만** 새로운 롤아웃이 시작됨

k8s Deployment는 아래 2개 롤아웃 전략을 지원

| 전략 | 작동 방식 | 가장 적합한 사용 사례 |
| --- | --- | --- |
| **rollingUpdate (기본값)** | 이전 버전의 파드(Pod)를 점진적으로 삭제하면서 새 버전의 파드를 생성. 서비스 중단이 발생 X | 다운타임이 허용되지 않는 대부분의 웹 서비스 및 애플리케이션 |
| **Recreate** | 이전 버전의 모든 파드를 한 번에 삭제한 후, 새 버전의 파드를 생성. 일시적인 서비스 중단이 발생 | 큐(Queue) 기반 시스템처럼 잠시 작업이 중단되어도 데이터 유실 없이 처리를 재개할 수 있는 워크로드 (다시 컨슘하면 됨) |

`rollingUpdate` 전략의 큰 장점

- 업데이트 기록을 유지하여, 문제가 발생했을 때 CLI 명령어를 통해 쉽게 이전 버전으로 **롤백**할 수 있다는 점

### 종합 예제

위 개념들은 워크플로우 안에서 연결됨

1. **버전 생성:** 개발팀이 웹 컨테이너 코드의 버그를 수정하고, 이미지 버전을 `v1.5.5`에서 `v1.5.6`으로 올림
2. **릴리스 정의:** 이 변경을 배포하기 위해, Deployment의 파드 템플릿(`spec.template`)에 있는 이미지 태그를 `v1.5.6`으로 수정하고, 이 템플릿 자체의 버전 레이블(`ver`)을 `1.5.9`로 업데이트. 이 모든 변경 사항은 여전히 `guest-book-stable` **릴리스**의 일부로 정의.
3. **롤아웃 실행:** `spec.template`의 내용(이미지 태그와 레이블)이 변경되었기 때문에, 쿠버네티스 Deployment 컨트롤러는 `rollingUpdate` 전략을 사용하여 자동으로 **롤아웃**을 실행하고 무중단 업데이트를 완료.

**심층 분석**

하나의 Deployment에 애플리케이션 버전(`1.6.9`), 파드 버전(`1.5.8`), 컨테이너 이미지 버전(`v1.5.5`)이 모두 다를 수 있을까…?

→ 세 가지가 **서로 독립적인 라이프사이클**을 가지기 때문

- 앱 `appver: 1.6.9` (최상단 `metadata`)
    - 여러 서비스(웹, DB 등)를 포함하는 **전체 애플리케이션**의 버전. 다른 서비스가 변경될 때 함께 올라갈 수 있음.
- 파드 `ver: 1.5.8` (`spec.template.metadata`)
    - 컨테이너 이미지뿐만 아니라 환경 변수, 리소스 제한 등 **파드 명세(Pod Specification) 자체**의 버전.
    - 컨테이너는 그대로인데 ConfigMap이나 Secret 참조만 바뀌어도 이 버전은 올라갈 수 있다는…
- 컨테이너 `image: ...:v1.5.5` (`spec.template.spec.containers`)
    - 빌드된 **컨테이너 이미지 아티팩트**의 구체적 버젼. 코드의 작은 버그 수정만으로도 이 버전은 자주 변경될 수 있음

참고로 훌륭한 릴리스는 Deployment만으로 구성되지 않음.

- 헬름 패키징 시, 동일한 서비스(신규 배포 및 업그레이드)는 동일한 헬름 차트로 묶어야 함
    - 그래야 쉽게 롤백 가능
- 예제에 포함된 `Job` 리소스는 `helm.sh/hook` 어노테이션을 가지고 있음.
    - 헬름과 같은 도구가 업그레이드나 롤백 직전에 데이터베이스 백업과 같은 관련 배치 작업을 실행하도록 하여, **릴리스가 관련된 모든 구성 요소의 라이프사이클을 함께 관리**하는 개념.

### 포인트 기억

위 프로세스를 기반으로 애플리케이션을 안정적으로 배포하고 관리하기 위해 다음의 원칙 준수 권장

1. **독립적인 버전 관리 유지:** 애플리케이션, 파드 명세, 컨테이너 이미지에 대해 독립적인 시맨틱 버전을 사용하여 유연성을 극대화 이를 통해 각 구성 요소의 변경이 다른 부분에 미치는 영향을 최소화
2. **릴리스 추적성 확보:** CI/CD 파이프라인에서 생성된 고유한 릴리스 ID(예: `34e57f01`)를 레이블로 사용하여 클러스터에서 어떤 버전이 실행 중인지 명확히 추적하고 롤백
3. **릴리스 명명 규칙 합의:** 조직에 맞는 릴리스 명명법(예: `stable`, `canary`, `alpha`)에 대해 팀과 합의하여 배포 상태를 명확히 정형화
4. **헬름(Helm) 현명하게 사용하기:** 헬름을 사용한다면, 함께 업그레이드되거나 롤백되어야 하는 서비스들을 하나의 차트(Chart)로 묶어 라이프사이클 관리를 단순화