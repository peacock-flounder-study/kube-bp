
# 5장 **지속적 통합, 테스트 및 배포**

### CI/CD 파이프라인의 구성 요소

버전 관리 (Version Control)

모든 CI/CD 파이프라인은 버전 관리 시스템에서 시작

- **Git 사용**: 업계 표준인 **Git**을 사용하며, 일반적으로 `main` 브랜치가 프로덕션 코드를 관리
- **단일 리포지토리 (Monorepo)**: 애플리케이션 코드와 Kubernetes 매니페스트, Helm 차트 같은 구성 코드를 하나의 리포지토리에서 관리하는 것이 좋음.

### 지속적 통합 (Continuous Integration - CI)

CI는 코드 변경 사항을 중앙 리포지토리에 지속적으로 통합하는 프로세스

> "큰 변경 사항을 덜 자주 커밋하는 대신, 작은 변경 사항을 더 자주 커밋”
> 
- **자동화된 빌드**: 코드 변경이 커밋될 때마다 빌드가 자동으로 시작되어 문제 발생 시 피드백을 제공.
- **DevOps 문화**: 운영팀이 애플리케이션 코드와 개발 워크플로우에 더 가까워지는 DevOps 문화를 촉진. (예: Jenkins)

테스트 (Testing)

자동화된 테스트는 파이프라인의 핵심

- **신속한 피드백 루프**: 테스트의 주된 목표는 "빌드를 중단시키는 코드 변경에 대한 피드백을 신속하게 제공하는 것"
- **다양한 테스트 유형**: 단위 테스트, 스모크 테스트 등 다양한 유형의 테스트를 파이프라인에 통합해야 함. (예: `helm lint`는 Helm 차트의 잠재적 문제를 검사)
- 코드 테스트와 프로덕션 배포는 개발팀과 운영팀 모두의 노력이 필요한 엔드-투-엔드 프로세스

컨테이너 빌드 및 최적화

- **이미지 크기 최적화**: 이미지 크기가 작을수록 다운로드 및 배포 시간이 단축되고 보안이 강화됨
- **최적화 전략**:
    - **다단계 빌드 (Multi-stage builds)**: 최종 이미지에 빌드 도구나 불필요한 종속성을 포함하지 않아 이미지 크기를 크게 줄임
    - **최적화된 기본 이미지 사용**: `alpine`과 같이 불필요한 OS 요소를 제거한 경량화된 베이스 이미지를 사용
- **컨테이너 이미지 태깅 (Tagging)**:
    
    > "'최신(latest)' 태그는 절대 사용 X." 
    이는 버전 정보가 아니므로 어떤 코드가 배포되었는지 추적할 수 없음
    > 
    - **고유한 태그 사용**: 모든 빌드 이미지는 고유한 태그를 가져야 함
    - **효과적인 태그 전략**: `BuildID`, `Git 해시`, `githash-buildID` 조합 등을 사용

---

### 지속적 배포 (Continuous Deployment - CD)

CD는 CI 파이프라인을 성공적으로 합의 및 통과한 코드 변경 사항을 "사람의 개입 없이 프로덕션에 배포하는 프로세스"

- **불변성(Immutability)**
    - 컨테이너 이미지는 개발, 스테이징, 프로덕션을 거치며 변경되지 않는 '불변의 객체'가 되어 환경 간의 일관성을 보장
- **전제**:
    - 견고한 CI 파이프라인이 먼저 구축되어야 잘못된 코드가 프로덕션까지 배포되는 위험 방지

### 배포 전략

**롤링 업데이트 (Rolling Update)**

Kubernetes의 기본 배포 방식으로, 다운타임 없이 점진적으로 새 버전의 파드(Pod)로 교체

- 업데이트 중에는 두 버전의 애플리케이션이 동시에 실행되므로, 데이터베이스 스키마 등이 하위 호환성을 가져가도록 해야 함.
- 예를 들어 `readinessProbe`와 `preStop` hook을 활용하여 연결 끊김을 방지.

**블루/그린 배포 (Blue/Green Deployment)**

기존 환경(블루)과 동일한 새 환경(그린)을 함께 배포한 후, 트래픽을 한 번에 전환하는 방식.

- 롤백이 매우 빠르고 간단
- 두 배의 리소스가 필요하며, 두 환경을 동시에 운영해야 하는 복잡성이 존재

**카나리 배포 (Canary Deployment)**

전체 사용자 중 일부에게만 새 버전을 먼저 공개하여 테스트하는 점진적인 배포 방식

- 새로운 릴리즈로의 트래픽 이동을 훨씬 더 세밀하게 제어할 수 있어 위험을 최소화
- Istio, Linkerd 같은 서비스 메시 기술을 활용하여 트래픽을 정교하게 제어 가능

프로덕션 환경에서의 테스트 → 신뢰 확보

- **필수 요소**:
    1. **깊이 있는 가시성(Observability)**: 최종 사용자 경험에 영향을 미치는 지표를 관찰할 수 있어야 함.
    2. **자동화 고도화 필요**: 시스템 장애 발생 시 자동으로 복구할 수 있는 체계가 필요
- **카오스 엔지니어링 (Chaos Engineering)**:
    - **정의**: "통제된 실험을 통해 시스템의 약점을 미리 발견하고 배우는 과정"
    - **핵심 원칙**: 실험 시 발생할 수 있는 문제 범위를 최소화하는 '폭발 반경(blast radius)'을 작게 설정하는 것이 매우 중요
        
        ```yaml
        실험 대상: 단일 마이크로서비스의 한 인스턴스
        영향 범위: 
        ├── 해당 서비스의 트래픽 일부만 영향
        ├── 다른 서비스들은 정상 동작
        └── 전체 사용자 중 1-5%만 영향
        ```
        

---

CI/CD 핵심 모범 사례 (Best Practices)

1. **빠른 빌드와 자동화**: CI 단계에서는 신속한 피드백을 제공하여 개발자가 문제에 빠르게 대응하도록 자동화에 집중
2. **신뢰할 수 있는 테스트**: 파이프라인의 모든 단계에서 신뢰도 높은 테스트를 제공하는 데 집중
3. **파이프라인 버전 관리**: 애플리케이션 코드와 함께 `.drone.yml` 같은 파이프라인 정의 파일도 버전 관리하면 좋음
4. **이미지 최적화**: 멀티 스테이징 빌드를 활용하여 이미지 크기와 시스템에서 공격자가 접근하거나 악용할 수 있는 모든 진입점과 취약점의 총합을 모두 줄이길 권장
5. **올바른 이미지 태그 사용**: **`latest`** 태그 대신, 빌드 ID나 Git 커밋 해시처럼 추적 가능한 태그를 사용
6. **점진적인 CD 전략 도입**: 처음에는 롤링 업데이트로 시작하고, 익숙해지면 블루/그린, 카나리아 배포를 도입
7. **프로덕션 테스트 도입**: 소규모의 통제된 실험으로 시작하여 애플리케이션의 안정성을 검증하고 모니터링 체계를 강화해보는 프로세스를 권장


----------------------------
# CH6. 버전, 릴리스, 롤아웃 완벽 가이드

'어떻게 애플리케이션을 안전하고 빠르게 업데이트할 것인가'

- 과거의 전통적인 애플리케이션(모놀리식)은 시간이 지나면서 너무 거대해져, 비즈니스가 요구하는 속도에 맞춰 업그레이드하기가 매우 어려웠음

오늘날 쿠버네티스와 함께하는 현대적인 개발의 목표는 명확

- 바로 '다운타임 없는 업그레이드(zero-downtime upgrades)'와 신속한 기능 반복을 달성하는 것.
- **버전 관리(Versioning), 릴리스(Release), 롤아웃(Rollout)**를 통해 수행

### '버전 관리'

소프트웨어 버전 관리는 특정 시점의 코드 상태를 식별하는 고유한 번호나 이름을 부여하는 프로세스. 

특히 여러 서비스가 서로 통신하는 마이크로서비스 아키텍처에서는 **시맨틱 버전 관리(Semantic Versioning)** 방식이 가장 유용

시맨틱 버전 관리는 `주.부.패치 (Major.Minor.Patch)`라는 세 부분으로 구성된 숫자 체계를 사용. 

각 부분은 다음과 같은 명확한 의미를 가지게 됨

| 구성요소 | 의미 | 변경되는 경우의 예시 |
| --- | --- | --- |
| **주 (Major)** | 이전 버전과 호환되지 않는 큰 변경 | API 호환성이 깨지는 대대적인 코드 수정 |
| **부 (Minor)** | 이전 버전과 호환되는 새로운 기능 추가 | 새로운 API 기능이 추가되었지만, 기존 기능은 그대로 작동 |
| **패치 (Patch)** | 이전 버전과 호환되는 버그 수정 | API 변경 없이 기존 코드의 버그를 해결 |

마이크로서비스 환경에서 시맨틱 버전 관리가 중요한 이유는, 개발자가 다른 서비스의 코드를 직접 보지 않고도 **버전 번호만으로 업데이트가 자신의 서비스에 미칠 영향을 예측**할 수 있게 해주기 때문. 

- eg. 부(Minor) 버전 업데이트는 기존 기능을 망가뜨리지 않을 것이라는 신뢰를 줌.
- 이는 시스템 전체의 안정성을 유지하는 데 매우 중요

### ‘Release'는 어떻게 버전을 관리하나

'무엇'을 업데이트할지(버전) 정의했으니, 실제로 '어떻게' 배포하고 관리할지에 대한 내용

쿠버네티스는 자체적으로 '릴리스(Release)'라는 개념을 가진 객체나 컨트롤러를 내장 X. Deployment와 같은 리소스의 메타데이터 레이블을 사용하여 릴리스를 식별하고 관리.

- 이 레이블은 Deployment의 최상단 `metadata.labels`에 추가될 수도 있고, 파드 템플릿 영역인 `spec.template.metadata.labels`에 추가될 수도 있음. 이 위치 선택은 '롤아웃'이 어떻게 트리거되는지에 중요한 영향을 미치므로 신중해야함
- 가장 대표적인 예는 헬름(Helm)
    - 헬름은 쿠버네티스 패키지 관리 도구로, 동일한 애플리케이션(차트)의 여러 실행 인스턴스를 구별하기 위해 공식적으로 '릴리스'라는 개념을 도입.
- 릴리스 이름은 특정 버전이 클러스터 내에서 어떤 역할을 하는지 명확히 알려주는 human friendly한 식별자 역할을 함. 일반적으로 다음과 같은 이름들이 사용됨
    - 조직의 운영 템포에 맞는 알맞은 릴리스 네이밍 컨벤션 정하자
    - `stable`: 안정화된 버전으로, 실제 사용자들에게 서비스되는 버전
    - `canary`: 새로운 기능을 소수의 사용자에게 먼저 공개하여 테스트하는 버전
    - `alpha`: 내부 개발 및 테스트 단계에 있는 버전

요약

- '릴리스'는 특정 **버전**의 애플리케이션이 클러스터에 배포된 **실행 인스턴스**에 붙이는 이름표와 같음.
    - 이름표 덕분에 우리는 지속적인 배포(CD) 파이프라인에서 어떤 버전이 어디서 실행 중인지 명확하게 추적하고 관리 가능

### '롤아웃'이 애플리케이션을 업데이트하는 방식

버전을 만들고 릴리스로 포장했다면, 이제 마지막 단계인 실제 배포 프로세스인 Rollout

'롤아웃(Rollout)'은 쿠버네티스의 Deployment 컨트롤러가 애플리케이션의 현재 상태를 의도한 새로운 상태로 업데이트하는 자동화된 프로세스를 의미

Deployment 업데이트는 `metadata` 섹션의 레이블을 변경한다고 해서 트리거 X 

- 오직 **`spec.template` 필드의 내용이 변경되었을 때만** 새로운 롤아웃이 시작됨

k8s Deployment는 아래 2개 롤아웃 전략을 지원

| 전략 | 작동 방식 | 가장 적합한 사용 사례 |
| --- | --- | --- |
| **rollingUpdate (기본값)** | 이전 버전의 파드(Pod)를 점진적으로 삭제하면서 새 버전의 파드를 생성. 서비스 중단이 발생 X | 다운타임이 허용되지 않는 대부분의 웹 서비스 및 애플리케이션 |
| **Recreate** | 이전 버전의 모든 파드를 한 번에 삭제한 후, 새 버전의 파드를 생성. 일시적인 서비스 중단이 발생 | 큐(Queue) 기반 시스템처럼 잠시 작업이 중단되어도 데이터 유실 없이 처리를 재개할 수 있는 워크로드 (다시 컨슘하면 됨) |

`rollingUpdate` 전략의 큰 장점

- 업데이트 기록을 유지하여, 문제가 발생했을 때 CLI 명령어를 통해 쉽게 이전 버전으로 **롤백**할 수 있다는 점

### 종합 예제

위 개념들은 워크플로우 안에서 연결됨

1. **버전 생성:** 개발팀이 웹 컨테이너 코드의 버그를 수정하고, 이미지 버전을 `v1.5.5`에서 `v1.5.6`으로 올림
2. **릴리스 정의:** 이 변경을 배포하기 위해, Deployment의 파드 템플릿(`spec.template`)에 있는 이미지 태그를 `v1.5.6`으로 수정하고, 이 템플릿 자체의 버전 레이블(`ver`)을 `1.5.9`로 업데이트. 이 모든 변경 사항은 여전히 `guest-book-stable` **릴리스**의 일부로 정의.
3. **롤아웃 실행:** `spec.template`의 내용(이미지 태그와 레이블)이 변경되었기 때문에, 쿠버네티스 Deployment 컨트롤러는 `rollingUpdate` 전략을 사용하여 자동으로 **롤아웃**을 실행하고 무중단 업데이트를 완료.

**심층 분석**

하나의 Deployment에 애플리케이션 버전(`1.6.9`), 파드 버전(`1.5.8`), 컨테이너 이미지 버전(`v1.5.5`)이 모두 다를 수 있을까…?

→ 세 가지가 **서로 독립적인 라이프사이클**을 가지기 때문

- 앱 `appver: 1.6.9` (최상단 `metadata`)
    - 여러 서비스(웹, DB 등)를 포함하는 **전체 애플리케이션**의 버전. 다른 서비스가 변경될 때 함께 올라갈 수 있음.
- 파드 `ver: 1.5.8` (`spec.template.metadata`)
    - 컨테이너 이미지뿐만 아니라 환경 변수, 리소스 제한 등 **파드 명세(Pod Specification) 자체**의 버전.
    - 컨테이너는 그대로인데 ConfigMap이나 Secret 참조만 바뀌어도 이 버전은 올라갈 수 있다는…
- 컨테이너 `image: ...:v1.5.5` (`spec.template.spec.containers`)
    - 빌드된 **컨테이너 이미지 아티팩트**의 구체적 버젼. 코드의 작은 버그 수정만으로도 이 버전은 자주 변경될 수 있음

참고로 훌륭한 릴리스는 Deployment만으로 구성되지 않음.

- 헬름 패키징 시, 동일한 서비스(신규 배포 및 업그레이드)는 동일한 헬름 차트로 묶어야 함
    - 그래야 쉽게 롤백 가능
- 예제에 포함된 `Job` 리소스는 `helm.sh/hook` 어노테이션을 가지고 있음.
    - 헬름과 같은 도구가 업그레이드나 롤백 직전에 데이터베이스 백업과 같은 관련 배치 작업을 실행하도록 하여, **릴리스가 관련된 모든 구성 요소의 라이프사이클을 함께 관리**하는 개념.

### 포인트 기억

위 프로세스를 기반으로 애플리케이션을 안정적으로 배포하고 관리하기 위해 다음의 원칙 준수 권장

1. **독립적인 버전 관리 유지:** 애플리케이션, 파드 명세, 컨테이너 이미지에 대해 독립적인 시맨틱 버전을 사용하여 유연성을 극대화 이를 통해 각 구성 요소의 변경이 다른 부분에 미치는 영향을 최소화
2. **릴리스 추적성 확보:** CI/CD 파이프라인에서 생성된 고유한 릴리스 ID(예: `34e57f01`)를 레이블로 사용하여 클러스터에서 어떤 버전이 실행 중인지 명확히 추적하고 롤백
3. **릴리스 명명 규칙 합의:** 조직에 맞는 릴리스 명명법(예: `stable`, `canary`, `alpha`)에 대해 팀과 합의하여 배포 상태를 명확히 정형화
4. **헬름(Helm) 현명하게 사용하기:** 헬름을 사용한다면, 함께 업그레이드되거나 롤백되어야 하는 서비스들을 하나의 차트(Chart)로 묶어 라이프사이클 관리를 단순화