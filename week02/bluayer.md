# Chapter 03. 모니터링과 로깅
## 메트릭 vs 로그

상호 보완적이지만 용도가 다르다.

- 메트릭 : 정해진 기간에 측정한 수치
- 로그 : 에러, 경고, 중요 이벤트 등 프로그램 실행 중 일어난 사건을 추적

## 모니터링 기법

Closed-box Monitoring : 애플리케이션 외부에서 모니터링 (CPU, Memory, Storage)
Open-box Monitoring : 총 HTTP 요청 수, 500 에러 횟수, 요청 레이턴시 같은 애플리케이션 상태에 주목

## 모니터링 패턴

24/7 가동되는 VM은 모든 상태가 보존되는지 확인하는 식으로 모니터링하지만, k8s는 수명이 짧고 다이내믹한 파드의 특성을 잘 나타낼 수 있는 모니터링 체계가 필요하다.

1. USE method : 사용률(Utilization), 포화도(Saturation), 에러 수(Errors) -> 주로 인프라 수준
2. RED 방법론 : 처리율(Rate), 에러 수(Errors), 처리 시간(Duration) -> 애플리케이션의 엔드 유저 경험 위주

두 방법론은 서로 상호 보완적

## 쿠버네티스 메트릭 개요

컨트롤 플레인 : API 서버, etcd, 스케줄러, 컨트롤러 매니저
노드 : kubelet, 컨테이너 런타임, kube-proxy, kube-dns, 파드

클러스터와 애플리케이션의 정상 가동 -> 모든 컴포넌트를 빠짐없이 모니터링

### cAdvisor

Container Advisor(cAdvisor)는 노드에서 실행 중인 컨테이너의 리소스와 메트릭 수집

k8s kubelet과 한 몸으로 클러스터의 모든 노드에서 실행됨.

cgroup 트리를 통해 메모리, CPU 메트릭을 수집하며, 리눅스 커널에 내장된 statfs로 디스크 메트릭을 수집한다.

**모든 컨테이너 메트릭의 SSOT**

### 메트릭 서버

1. Metric Server는 resource metric API의 표준 구현체로, 리소스 메트릭을 kubelet API에서 수집해서 메모리에 저장한다. 수집된 메트릭은 스케줄러, HPA, VPA에서 사용된다.
2. Custom metric API를 사용하면 임의의 메트릭을 수집할 수 있고 확장할 수 있다. 프로메테우스는 커스텀 메트릭 기반의 HPA를 사용할 수 있는 최초의 커스텀 메트릭 어댑터다.

### kube-state-metrics

k8s에 저장된 오브젝트를 모니터링하는 k8s add-on

클러스터에 배포된 k8s 오브젝트의 상태 파악이 주된 관심사다.

***예시***

- 파드
  - 클러스터에 파드가 몇 개 배포되었나?
  - 대기 상태인 파드는 몇 개인가?
- 디플로이먼트
  - 실행 중인 파드 대비 몇 개의 파드가 의도한 상태인가?
  - 레플리카는 몇 개 사용할 수 있나?
  - 어떤 디플로이먼트가 업데이트되었나?
- 노드
  - 내 노드의 상태는 어떠한가?
  - 클러스터에 할당 가능한 CPU 코어 수는 몇 개인가?
  - 스케줄링 불가능한 노드가 있는가?

꽤 많은 오브젝트 타입을 추적함

## 어떤 메트릭을 모니터링하나?

다음의 요소를 계층적으로 접근하기
- 물리 또는 가상 노드 (CPU, Memory..)
- 클러스터 컴포넌트 (etcd 레이턴시)
- 클러스터 애드온 (클러스터 오토스케일러, 인그레스 컨트롤러)
- 엔드 유저 애플리케이션

예시 : 어떤 파드가 자꾸 대기 상태에 빠질 경우, 일단 노드의 리소스 사용률을 체크하고 문제가 없으면 클러스터 수준의 컴포넌트를 타깃팅하는 식으로 살펴보기

## 모니터링 툴

- 프로메테우스
- InfluxDB
- Datadog
- Sysdig Monitor
- CSP 툴들

프로메테우스, 로깅

# Chapter 04. 구성, 시크릿, RBAC

## 컨피그맵과 시크릿을 통한 구성

### 컨피그맵

구성 정보를 애플리케이션에 전달.

### 시크릿

컨피그맵을 사용하는 이유와 필요성은 대부분 시크릿에도 적용된다. 시크릿 데이터는 쉽게 감출 수 있거나 적어도 환경에 지원된다면 저장 및 취급 시 암호화해야 한다.

- generic
- docker-registry
- tls

### 컨피그맵, 시크릿 API 모범 사례

컨피그맵, 시크릿의 사용상 문제는 대부분 오브젝트에 있는 데이터가 업데이트되는 시점에 변경된 내용이 어떻게 처리되는지 정확히 모르기 때문에 생긴다.

- 새 버전의 파드를 재배포하지 않고 다이내믹하게 애플리케이션을 변경하려면 컨피그맵/시크릿을 별도의 볼륨으로 마운트하고 필요 시 변경된 파일 데이터를 감지하는 파일 감시기(file watcher)를 구성하자.
  - volumeMounts를 사용할 때 두 가지 주의할 점이 있다.
    - 첫째, 컨피그맵/시크릿이 생성되자마자 파드 스펙에 볼륨으로 추가하자. 그런 다음 컨테이너의 파일시스템에 해당 볼륨을 마운트한다. 
    - 둘째, volumeMounts.subPath 프로퍼티를 사용해서 컨피그맵/시크릿을 마운트하지 말자. 이렇게 하면 컨피그맵/시크릿을 새 데이터로 수정해도 볼륨에 있는 데이터가 바로 업데이트 안 된다.
- 파드 배포 전에 컨피그맵/시크릿은 자신을 사용할 파드의 네임스페이스에 존재해야 한다. (optional 플래그를 세팅하지 말거나, false로 세팅)
- Admission controller를 사용하여 특정한 구성 데이터가 존재하도록 하거나, 어떤 구성 값 세트가 없는 디플로이먼트가 배포되지 않도록 방지하자.
- Helm으로 애플리케이션을 릴리즈할 경우, Life cycle hook을 걸어 디플로이먼트를 배포하기 직전에 컨피그맵/시크릿 템플릿 배포되도록 하자.
- 시스템 환경 변수 사용 : 1/ envFrom 사용 2/ configMapRef나 secretRef 아니면 configMapKeyRef나 secretKeyRef를 사용하여 각 키별로 값을 할당한다.
- configMapKeyRef나 secretKeyRef를 사용할 경우, 실제로 키가 존재하지 않으면 파드가 시작되지 않는다.
- 컨피그맵/시크릿 데이터를 환경 변수를 전달하는 경우, 컨피그맵/시크릿 데이터를 수정해도 파드 안에 있는 값은 자동 업데이트 되지 않고 **반드시** 파드 재시작해야 반영된다.
- 컨피그맵/시크릿이 조금이라도 변경되면 디플로이먼트는 모조리(!) 업데이트해야 한다. 디플로이먼트의 checksum/config annotation을 사용해서 체크섬을 확인한다.

## 시크릿 모범 사례
- k8s API에 직접 액세스할 필요가 없으면, Service Account에 대한 API Credential이 자동 마운트되지 않게 차단하는 것이 좋다.
- imagePullSecrets을 서비스어카운트에 할당하면 pod.spec에 선어하지 않아도 파드가 시크릿을 자동 마운트한다.
- 보안팀은 시크릿을 생성/암호화하는 일을 맡고, 개발자는 시크릿 네임을 정확히 잘 참조하기만 하면 된다.

**Service Account란**
파드 내부의 프로세스는, 자신에게 부여된 서비스 어카운트의 식별자를 사용하여 클러스터의 API 서버에 인증할 수 있다.
- 서비스 어카운트는 쿠버네티스의 경우 파드의 일부 컨테이너에서 실행되는 애플리케이션 프로세스를 위한 것이다.
- 쿠버네티스에서 서비스 어카운트는 네임스페이스별로 구분된다. 두 개의 서로 다른 네임스페이스는 동일한 이름의 서비스어카운트를 각자 가질 수 있다.
- 실 사용자를 온보딩하는 단계와 서비스어카운트를 생성하는 단계를 분리하는 것은, 워크로드가 최소 권한 원칙을 따르기 쉬워지게 한다.

## RBAC

- 인가(Authorization, 권한 부여) -> RBAC
- Admission Controller : 정의된 규칙 및 정책에 따라 API 요청을 허용/거부 또는 변경한다. PodSecurity, ResourceQuota, ServiceAccount Controller 등 많은 어드미션 컨트롤러를 기본 제공한다.

### RBAC 기초

k8s에서 RBAC을 사용하려면 주체, 규칙, 롤 바인딩의 세 가지 주요 컴포넌트를 정의해야 한다.

**주체(Subject)** : 실제로 액세스를 확인할 대상이다. 보통 유저, 서비스 어카운트, 그룹 중 하나다.

**규칙(Rule)** : API에 있는 어떤 오브젝트나 그룹에서 실제로 수행가능한 액션 리스트다. 

**롤(Role)** : 규칙의 scope(범위)를 말한다. k8s에는 role(어느 한 네임스페이스) / clusterRole(모든 클러스터, 모든 네임스페이스)에 적용된다.

**Rolebinding** : 주체(e.g. 유저, 그룹)를 특정 롤에 매핑한 것이다. 특정 네임스페이스로 범위가 국한된 roleBinding과 전체 클러스터에 고루 적용되는 clusterRoleBinding 두 가지 모드가 있다.

### RBAC 모범 사례
- k8s에서 실행하려고 개발한 app이 RBAC role or roleBinding이 필요한 경우는 극히 드물다.
- 애플리케이션이 직접 k8s API 액세스하여 서비스에 추가한 엔드포인트에 맞게 구성을 변경하거나 등이 필요하다면 새 서비스 계정(SA)를 만들어 파드 스펙에 지정하는 것이 좋다. 그런 다음, 원하는 목표 달성에 필요한 최소 권한이 부여된 롤을 생성한다.
- 필요 시 Identity 관리와 2FA까지도 가능한 아이덴티티 인증을 구현하자.
- 특수 작업 수행을 위해 짧은 시간 동안 권한을 승격시켜야 할 유저가 있다면 JIT 액세스 시스템을 사용하자. 엄격한 로그인 감시를 위해 다른 identity를 발급한다.
- CI/CD 툴로 서비스를 배포하는 계정은 별도로 마련하자.
- Helm v2는 tiller 기반이기 때문에 RBAC 액세스를 사용하는 v3를 사용하자.
- Secret API의 watch, list를 필요로 하는 애플리케이션은 삼가자. 시크릿을 볼 수 있기 때문에!
