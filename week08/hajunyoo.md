# 16장

### 볼륨 및 볼륨 마운트의 기본

컨테이너에 외부 볼륨을 마운트하는 기능만으로는 대규모 스테이트풀 애플리케이션을 실행하기에는 부족

상태 유지가 필요한 모든 워크로드가 복잡한 데이터베이스일 필요는 없음. 

컨테이너화된 워크로드는 특정 디렉터리가 존재하고 해당 디렉터리에 정보를 읽고 쓸 수 있음

- **컨테이너 런타임 지원**
    - Docker, rkt, CRI-O, Singularity와 같은 주요 컨테이너 런타임은 외부 스토리지 시스템에 매핑된 컨테이너에 볼륨을 마운트하는 것을 지원
- **외부 스토리지 유형**
    - 외부 스토리지는 메모리 위치, 컨테이너 호스트의 경로, 또는 NFS, Glusterfs, CIFS, Ceph와 같은 외부 파일 시스템일 수 있음
- **HostPath 마운트**
    - `hostPath` 마운트를 사용하여 host log와 컨테이너 애플리케이션 로그 모두에 대한 볼륨을 읽을 수 있는 호스트 기반 로깅 도구를 사용하는 인프라 접근 방식 존재

**볼륨 모범 사례**

- **데이터 공유 제한**
    - 데이터를 공유해야 하는 여러 컨테이너(어댑터 또는 앰배서더 패턴)가 필요한 파드에 볼륨 사용을 제한하고, 이러한 공유 패턴에는 **`emptyDir`**을 사용해야 함
- **노드 기반 액세스**
    - 노드 기반 에이전트 또는 서비스에서 데이터에 액세스해야 하는 경우 **`hostDir`**을 사용.
- **로깅 관리:**
    - 중요한 로그를 로컬 디스크에 기록하는 서비스는 가능하면 `stdout` 또는 `stderr`로 변경
    - 볼륨 맵 대신 Kubernetes 인식 로그 집계 시스템이 로그를 스트리밍하도록 해야 함

### 4. 컨테이너 스토리지 인터페이스 (CSI) 및 FlexVolume

대부분의 볼륨 플러그인은 Kubernetes 코드베이스에 직접 코드가 추가되기를 기다려야 했음

하지만 컨테이너 스토리지 인터페이스 (CSI)와 **FlexVolume**은 스토리지 벤더가 직접 코드 추가를 기다릴 필요 없이 사용자 정의 스토리지 플러그인을 생성할 수 있도록 해준다 ("아웃-오브-트리" 볼륨 플러그인).

관리자가 쿠버네티스 클러스터에 익스텐션으로 배포하는 기능

- **CSI의 목표**
    - 스토리지 공급업체(SP)가 플러그인을 한 번만 개발하면 여러 컨테이너 오케스트레이션(CO) 시스템에서 작동할 수 있도록 하는 업계 표준 인터페이스를 정의하는 것
- **FlexVolume의 제약**
    - 스토리지 공급업체가 추가 기능을 추가하는 전통적인 방식이었지만, 이 인터페이스를 사용할 클러스터의 모든 노드에 특정 드라이버(실행 파일)를 설치해야 한다는 가장 큰 장애물이 있음

### 5. 스테이트풀 애플리케이션 및 StatefulSet

**StatefulSet의 기능**

- 스테이트풀셋(StatefulSet)은 보다 안정적인 노드/파드 동작을 기대하는 애플리케이션 시스템을 더 쉽게 실행할 수 있도록 도입됨
    - 스테이트풀셋은 레플리카셋과 거의 정반대의 기능을 제공
- **예측 가능한 이름:**
    - 파드는 고유하고 순서가 지정된 이름을 가짐 (예: `mongo-0`, `mongo-1`).
- **순차적 스케일링:**
    - 새 파드는 다음 파드가 추가되기 전에 완전히 온라인 상태여야 함.
- **역순 축소:**
    - 파드는 **역순**으로 축소.
- **개별 주소 지정:**
    - 파드는 **헤드리스 서비스(Headless Service)** 뒤에 있는 이름으로 개별적으로 주소를 지정할 수 있음
    - 헤드리스 서비스는 일반적인 서비스와 동일하되 로드 밸런싱을 수행 X
- **볼륨 관리:**
    - 볼륨 마운트가 필요한 스테이트풀셋 파드는 정의된 **퍼시스턴트볼륨 템플릿**을 사용해야 하며, 스테이트풀셋이 삭제될 때 해당 볼륨은 삭제되지 않음

**스테이트풀셋 정의에서 디플로이먼트 정의와 구별되는 핵심적인 필드**

1. `serviceName` 필드와 헤드리스 서비스 (Headless Service)

- 스테이트풀셋 명세(`spec`)에는 **serviceName** 필드를 정의해야 함.
    - 이 필드는 스테이트풀셋의 파드가 개별적으로 주소 지정할 수 있도록 미리 생성된 **헤드리스 서비스**를 참조
    - 헤드리스 서비스는 일반 서비스와 달리 `clusterIP: None` 속성을 사용하여 **일반적인 로드 밸런싱을 수행하지 않음**
    - 이 헤드리스 서비스를 통해 스테이트풀셋의 각 파드는 `[파드 이름].[서비스 이름]` 형태의 안정적인 네트워크 식별자(DNS)를 갖게 됨 (예: `mongo-0.mongo`).

2. `volumeClaimTemplates` (퍼시스턴트볼륨 클레임 템플릿)

- 스테이트풀셋의 가장 중요한 차이점은 퍼시스턴트볼륨 템플릿 (`volumeClaimTemplates`)을 정의한다는 것
- 이 템플릿은 스테이트풀셋의 각 레플리카(파드)가 **고유하고 지속적인 스토리지**를 자동으로 요청하고 할당받을 수 있도록 함
- 디플로이먼트는 단순히 기존 PVC를 참조하거나 로컬 볼륨을 사용하는 반면,
- 스테이트풀셋은 템플릿을 사용하여 파드의 수명 주기와는 무관하게 지속되는 (그리고 스테이트풀셋이 삭제되어도 **자동으로 삭제되지 않는**) PV/PVC 쌍을 동적으로 생성

결론적으로, 디플로이먼트가 파드의 복제 및 대체에 중점을 둔다면, 스테이트풀셋은 **안정적인 개별 식별자, 순서가 지정된 생성/종료, 그리고 영구적으로 파드에 연결된 볼륨을 통해 데이터 지속성**을 보장하는 데 중점을 둠.

### StatefulSet 및 Operator 모범 사례

- **헤드리스 서비스 생성:**
    - 스테이트풀셋을 위한 헤드리스 서비스는 자동으로 생성되지 않으므로, 파드를 개별 노드로 적절하게 주소 지정하려면 **배포 시 생성**해야 함
- **노드 장애 처리:**
    - 스테이트풀셋의 일부인 파드는 노드 장애 시 자동으로 삭제되지 않고 `Terminating` 또는 `Unknown` 상태가 됨
- **강제 삭제 주의:**
    - 파드를 지우는 유일한 방법은 노드 오브젝트를 제거하거나, kubelet이 다시 작동하여 파드를 직접 삭제하거나, **운영자가 파드를 강제로 삭제**하는 것.
    - 강제 삭제는 마지막 옵션이어야 하며, 삭제된 파드가 있던 노드가 다시 온라인 상태가 되지 않도록 특별히 주의해야 함
    - 파드 강제 삭제 : **kubectl delete pod nginx-0 --grace-period=0 --force**
    - 파드를 강제로 삭제한 후에도 Unknown 상태로 유지될 수 있음
        - API 서버에 패치를 적용하면 항목이 삭제되고 스테이트풀셋 컨트롤러가 삭제된 파드의 새 인스턴스 ( kubectl patch pod nginx-0 -p '{"metadata":{"finalizers":null}}' )를 생성 하게 됨.
- **종료 후크 사용:**
    - 리더 선출 또는 데이터 복제 확인 프로세스가 있는 복잡한 데이터 시스템을 실행하는 경우, **`preStop hook`**을 사용하여 연결을 올바르게 닫고, 리더 선출을 강제하거나, 데이터 동기화를 확인한 후 정상 종료 프로세스를 사용하여 파드를 삭제해야 함
- **Operator 활용:**
    - 애플리케이션이 복잡한 데이터 관리 시스템인 경우, 애플리케이션의 복잡한 수명 주기 구성 요소를 관리하는 데 도움이 되는 Operator가 존재하는지 확인해 보아야 함


-----
# 17장

### Admission Control의 중요성 및 용도

Admission 컨트롤러는 모든 API 서버 요청의 경로에 위치하므로 다양한 방식으로 활용됨. 

주요 사용법은 세 가지 범주로 분류

1. **정책 및 거버넌스:** 
    - 비즈니스 요구 사항을 충족하는 정책을 시행
    - 예: `dev` 네임스페이스에서는 내부 Cloud 로드밸런서만 사용할 수 있도록 제한.
    - 예: 파드의 모든 컨테이너에 리소스 제한을 강제.
    - 예: 모든 리소스에 표준 레이블 또는 주석을 추가하여 기존 도구에서 검색할 수 있도록 함.
2. **보안:** 
    - 클러스터 전체에 일관된 보안 태세를 적용
    - **파드 보안 어드미션 컨트롤러**가 표준적인 예로, 파드 사양에 정의된 보안에 민감한 필드를 기반으로 파드의 승인 여부를 결정
    - 예: 특권 컨테이너 또는 호스트 파일시스템의 특정 경로 사용을 거부.
3. 리소스 관리
    - 어드미션 컨트롤러 이용 시, 쿠버네티스 클러스터가 모범 사례에 부합하는지 검사 가능
        - 모든 인그레스의 FQDN(전체 주소 도메인 네임)이 특정 접미어를 가지고 있는지 확인
        - 인그레스 FQDN이 중복되지 않게 함
        - 파드에 있는 모든 컨테이너에 리소스 리밋을 설정

### Admission Controller 유형

Admission 컨트롤러는 표준(Standard)과 동적(Dynamic)의 두 가지 클래스가 있음

| 유형 | 특징 |
| --- | --- |
| **표준 (Standard)** | API 서버에 컴파일되고 Kubernetes 릴리스와 함께 플러그인으로 제공되며, 
API 서버 시작 시 구성해야 함 |
| **동적 (Dynamic)** | 런타임에 구성할 수 있으며, 핵심 Kubernetes 코드베이스 외부에서 개발됨
유일한 동적 유형
- HTTP 콜백을 통해 어드미션 요청을 수신하는 **어드미션 웹후크** |

**기본 활성화 컨트롤러**

- 현재 Kubernetes 버전에서는 권장되는 어드미션 컨트롤러가 기본적으로 활성화되어 있음.
    - 기본적으로 활성화되는 컨트롤러 중에는 `MutatingAdmissionWebhook` 및 `ValidatingAdmissionWebhook`이 포함되어 있음
- kube api server 기동 시, 다음 플래그 이용시 추가 어드미션 컨트롤러 활성화
    - -enable-admission-plugins를 이용

### 변이 및 유효성 검사 (Mutation and Validation)

- **변경(Mutating) 어드미션 컨트롤러:** 승인하는 요청 오브젝트를 **수정**할 수 있음
- **유효성 검사(Validating) 어드미션 컨트롤러:** 요청 오브젝트를 **수정할 수 없음**
- 보안을 고려하여 `MutatingWebhookConfiguration`을 정의하고 단순히 유효성을 검사하는 것도 허용

### 어드미션 웹후크 (Admission Webhooks)

어드미션 웹후크는 동적 어드미션 컨트롤의 유일한 유형으로, HTTP 콜백을 통해 어드미션 요청을 수신. 

주요 장점은 동적으로 구성할 수 있다는 것

- `MutatingAdmissionWebhook`과 `ValidatingAdmissionWebhook` 표준 컨트롤러
    - 자체적으로 로직을 구현하지 않고, 클러스터 내에서 실행되는 웹후크 엔드포인트를 구성하여 어드미션 요청 개체를 전달하도록 함
- **구성 매니페스트:** `ValidatingWebhookConfiguration`과 `MutatingWebhookConfiguration` 리소스를 사용하여 정의
    - 두 리소스는 대부분 동일하지만, `MutatingWebhookConfiguration`은 객체 변경을 허용하며 `reinvocationPolicy` 필드를 추가로 가짐
    - 웹후크 구성 리소스에 대한 허용 요청에 대해서는 유효성 검사/뮤팅 웹훅이 호출되지 않음 
    (클러스터를 복구 불가능한 상태로 만드는 것을 방지).

### 권한 부여 모듈 (Authorization Modules)

권한 부여 모듈은 액세스 권한을 부여하거나 거부하는 역할을 담당하며, 명시적으로 정의된 정책에 따라 결정

정책이 없으면 모든 요청은 암시적으로 거부됨

Kubernetes는 다음 인가 모듈을 기본으로 제공

1. **ABAC (Attribute-Based Access Control):** 로컬 파일을 통해 권한 부여 정책을 구성
2. **RBAC (Role-Based Access Control):** Kubernetes API를 통해 인가 정책을 구성
3. **웹훅 (Webhook):** 원격 REST 엔드포인트를 통해 요청을 처리할 수 있음

**모듈 구성:** 

- 클러스터 관리자는 API 서버에서 `--authorization-mode` 플래그를 통해 모듈을 구성하며, 여러 모듈을 순서대로 확인할 수 있음

**결정 논리 (OR Logic):** 

- 단일 권한 부여 모듈이라도 요청을 승인하면 요청은 진행.
- **모든 모듈이 요청을 거부하는 경우에만** 사용자에게 오류가 반환됨

### 권한 부여 API

`authorization.k8s.io` API 그룹은 API 서버 권한을 외부 서비스에 노출하며 디버깅에 유용한 API를 포함

- `SelfSubjectAccessReview`: 현재 사용자에 대한 액세스 검토.
- `SubjectAccessReview`: 모든 사용자에 대한 액세스 검토.
- `SelfSubjectRulesReview`: 사용자가 지정된 네임스페이스에서 수행할 수 있는 작업 목록 반환.

`kubectl auth can-i` 명령어는 이러한 API를 쿼리하여 작동