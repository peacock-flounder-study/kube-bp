# 16. 상태와 스테이트풀 애플리케이션 관리

### 머신러닝에 쿠버네티스를 사용하면 좋은 점
- 컨테이너는 수명이 짧음 → 상태를 저장하는 컨테이너 기반 워크로드의 필요성이 대두됨.  
- 쿠버네티스가 사실상 표준 애플리케이션 컨테이너 런타임으로 자리 잡으면서 **데이터 중력**이 새로운 걸림돌로 작용함.  
- 네트워크 공유 폴더에 파일을 저장하는 단순한 방식부터 복잡한 데이터 관리 시스템까지, 다양한 상태 관리 모범 사례를 다룰 예정임.  

### 볼륨과 볼륨 마운트
- 주요 컨테이너 런타임은 모두 외부 스토리지 시스템에 매핑된 컨테이너에 **볼륨을 마운트**할 수 있도록 지원함.  
- 왜 필요한가? 일부 애플리케이션은 특정 정보를 로컬 파일시스템에 기록하도록 개발된 **레거시 애플리케이션**이기 때문임.  

### 볼륨 모범 사례
- **어댑터 패턴**이나 **앰배서더 타입 패턴**처럼 데이터 공유를 위해 여러 컨테이너가 필요한 파드에만 볼륨 사용을 제한함. (`emptyDir` 활용)  
- 중요한 애플리케이션 로그 및 이벤트를 **로컬 디스크에 기록하는 서비스**가 있는지 반드시 파악해야 함.  

### 쿠버네티스 스토리지
- **볼륨 마운트 뒤의 스토리지를 쿠버네티스가 직접 관리**할 수 있게 만드는 것이 핵심임.  

#### 퍼시스턴트볼륨
- 파드에 마운트된 모든 볼륨을 지탱하는 하부 디스크임.  
- 볼륨을 사용하는 파드의 라이프사이클과 독립적으로, 볼륨 자체의 **라이프사이클을 정의하는 클레임 정책**이 존재함.  
- 다이내믹하게 볼륨을 생성하려면 쿠버네티스에 **스토리지클래스**를 정의해야 함.  
  - 여러 타입과 클래스의 퍼시스턴트볼륨을 클러스터에 생성할 수 있으며, **클레임이 볼륨과 일치할 때만 실제 파드에 할당**됨.  

#### 퍼시스턴트볼륨클레임
- 파드가 사용할 스토리지 리소스 요건을 쿠버네티스에 알리는 **통신 수단**임.  
- 파드는 클레임을 참조하여 일치하는 볼륨이 있을 경우 해당 볼륨을 자동으로 할당받음.  
- **스토리지 요청 크기와 접근 모드**는 반드시 정의해야 하며, 특정 **스토리지클래스 지정**도 가능함.  

#### 스토리지클래스
- 사용할 볼륨 플러그인이 지정된 **스토리지클래스 오브젝트**를 만드는 것이 효율적임.  
- 클레임이 특정 스토리지클래스를 사용하도록 지정하면, 쿠버네티스는 해당 클래스의 파라미터에 따라 **퍼시스턴트볼륨을 다이내믹하게 생성**함.  

#### CSI와 플렉스 볼륨
- 스토리지 벤더가 쿠버네티스 코드에 의존하지 않고, **직접 커스텀 스토리지 플러그인**을 만들 수 있음.  
- 플렉스볼륨은 모든 노드에 특정 드라이버를 설치해야 해 불편함 → 특히 관리형 서비스에서는 노드 접근이 제한적이므로 어려움.  
- 이러한 제약을 해결하기 위해 **CSI(Container Storage Interface)** 가 등장함.  

#### 쿠버네티스 스토리지 모범 사례
- 가능한 한 **스테이트리스하게 설계**해야 함.  
- 컨테이너 기반 서비스 비중이 높아질수록 **데이터 퍼시스턴스**의 중요성이 커짐.  
- 어떤 워크로드가 디스크에 상태를 유지해야 하는지 꼼꼼히 파악해야 함.  
- 온프렘 또는 클라우드 아키텍처 설계 시, **컴퓨트 레이어와 데이터 레이어의 경계와 연계**를 신중히 검토해야 함.  
- 가급적 **디폴트 스토리지클래스 어드미션 플러그인**을 활성화하고, 디폴트 스토리지 클래스를 정의하는 것이 좋음.  

### 스테이트풀 애플리케이션
- 예전에는 복잡도가 높아, **확장성·내구성 기능을 작동시키는 데 많은 작업이 필요한 소규모 워크로드**에만 사용되었음.  
- **레플리카셋이 파드를 어떻게 스케줄링·관리하는지**, 그리고 그 방식이 기존 애플리케이션에 어떤 영향을 주는지 이해하는 것이 중요함.  
  - 레플리카셋의 파드는 스케줄링 시점에 스케일 아웃되며 **랜덤한 이름**을 가짐.  
  - 파드는 수시로 스케일 다운됨.  
  - 서비스와 연동되어 호출되며, **직접 네임이나 IP로 접근하지 않음.**  
  - 언제든 재시작되어 **다른 노드로 이동**될 수 있음.  
  - 퍼시스턴트볼륨이 매핑된 파드는 오직 **클레임을 통해 연결**되며, 새 이름의 파드가 생성되면 기존 클레임을 **재사용**할 수 있음.  

#### 스테이트풀셋
- **안정적인 노드/파드 운영이 필요한 애플리케이션**을 쉽게 실행할 수 있음.  
- 레플리카셋과는 반대로 동작함.  
  - 스테이트풀셋의 파드는 **순차적으로 네이밍되며 스케일 아웃**
  - **역순으로 스케일 다운**
  - **헤드리스 서비스 뒤의 네임**을 통해 각 파드에 개별 접근 가능
  - 볼륨 마운트가 필요한 파드는 **미리 정의된 퍼시스턴트볼륨 템플릿**을 사용해야 함.  
  - 스테이트풀셋이 삭제되어도 **파드의 클레임된 볼륨은 유지**됨.  

#### 오퍼레이터
- **커스텀 컨트롤러 로직** 덕분에 스테이트풀 애플리케이션뿐 아니라 복잡한 데이터 서비스 및 시스템에도 잘 맞음.  
- 오퍼레이터는 복잡한 쿠버네티스 시스템을 **자동으로 감독·관리하는 표준**으로 발전했음.  
- **오퍼레이터허브(OperatorHub)** 에서는 이미 만들어진 다양한 쿠버네티스용 오퍼레이터를 제공함.  

# 17. 어드미션 컨트롤과 인가

### 어드미션 컨트롤

#### 어드미션 컨트롤러
- **어드미션 컨트롤러**는 쿠버네티스 API 서버 요청을 처리하는 단계 중 하나로, **인증 및 인가 이후** 요청을 받아  
  요청 오브젝트를 스토리지에 저장하기 전에 **유효성 검증이나 변형 작업을 수행**함.  
- 주요 사용 목적은 다음과 같음.  
  - 정책 및 거버넌스
  - 보안
  - 리소스 관리

#### 어드미션 컨트롤러 타입
- **스탠다드**  
  - API 서버에 컴파일되어 각 쿠버네티스 릴리스에 포함됨.  
  - API 서버 시작 시 구성해야 함.  
- **다이내믹**  
  - 런타임 중 구성 가능하며, 코어 쿠버네티스 코드베이스에서 직접 개발할 필요가 없음.  

#### 어드미션 컨트롤 모범 사례
- 어드미션 플러그인 **순서는 중요하지 않음.**  
- 동일한 필드를 **중복 변형해서는 안 됨.**  
- 변형 어드미션 웹훅은 **멱등성(idempotency)** 을 유지해야 함.  
- 웹훅의 `failurePolicy` 필드는 **ignore** 또는 **fail** 로 설정해야 함.  
- 웹훅은 **신속히 응답**해야 함.  
- 웹훅이 작동하는 네임스페이스 범위는 `NamespaceSelector` 필드로 지정 가능함.  

### 인가
- 인가란 “이 사용자가 **어떤 리소스에 어떤 작업을 수행할 수 있는가**”를 결정하는 과정임.  
- 각 요청의 인가는 **인증 이후, 어드미션 이전**에 처리됨.  

#### 인가 모듈
- **접근 권한 부여·거부**를 담당
- 접근 권한은 명시된 정책에 따라 부여되며, 그 외의 요청은 기본적으로 **거부됨.**  
- 주요 인가 방식: **ABAC / RBAC / 웹훅 / 노드 기반 인가** 등.

#### 인가 모범 사례
- 여러 컨트롤 플레인을 사용하는 클러스터에서는 **ABAC 사용을 지양**해야 함
- **웹훅 모듈은 가급적 사용하지 않는 것**이 좋음
