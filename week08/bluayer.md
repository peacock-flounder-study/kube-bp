# Chapter 16. 상태와 스테이트풀 애플리케이션 관리

오퍼레이터 패턴을 이용하면 쿠버네티스 프리미티브는 물론, 비즈니스나 애플리케이션 로직을 커스텀 컨트롤러로 추가할 수 있다.

## 볼륨과 볼륨 마운트

외부 스토리지는 가장 간단하게는 메모리나 컨테이너 호스트의 경로부터 NFS, Glusterfs, CIFS, Ceph 등의 외부 파일 시스템까지 범위가 넓다.

stdout, stderr를 활용해 볼륨 맵을 사앙히자 말고 k8s-aware 로그 집계 시스템을 통해 로그를 스트리밍하자.

## 쿠버네티스 스토리지

### PV

파드에 마운트된 모든 볼륨을 떠받치는 하부 디스크.

다이나믹하게 볼륨을 생성하려면 StroageClass를 정의해야 한다.

볼륨 자체는 볼륨 플러그인이 지원

### PVC

파드가 사용할 스토리지의 리소스 요건을 쿠버네티스에 알리는 통신 수단.

파드는 클레임을 참조하여 일치하는 PV가 있으면 이를 파드에 할당.

DefaultStorageClass 어드미션 플러그인을 사용해서 디폴트 스토리지 클래스를 만들 수 있다.

***CSI와 플렉스볼륨***

CSI(Container Storage Interface)와 FlexVolume 덕분에 스토리지 벤더가 코드 추가를 기다릴 필요가 없다.

FlexVolume 인터페이스를 사용하는 클러스터의 모든 노드에 특정 들아ㅣ버를 설치해야 했었는데, CSI 플러그인이 해결사가 됨

### 쿠버네티스 스토리지 모범 사례

- 가급적 디폴트 스토리지 클래스 사용하자
- 적절한 레이블, 어피니티 활용
- 어느 워크로드가 디스크에 자신의 상태를 유지해야 하는지 파악하자
- 애플리케이션 코드를 스테이트리스하게 만들 수는 없을까?
- 볼륨에 저장된 데이터의 리던던시나 백업 처리는 "따로" 제공하지 않는다.
- 볼륨에 저장되는 데이터의 라이프 사이클이 적절한지 확인한다. reclaim policy!

## 스테이트풀 애플리케이션

- 레플리카셋의 파드는 스케줄링 시점에 스케일-아웃되고 랜덤하게 네이밍된다.
- 레플리카셋의 파드는 수시로 스케일-다운 된다.
- 레플리카셋의 파드는 서비스와 연동되어 호출되는 것이지, 절대로 직접 네임이나 IP 주소로 호출되는 일은 없다.
- 레플리카셋의 파드는 언제든지 재시작되어 다른 노드로 옮겨질 수 있다.
- PV가 매핑된 레플리카셋의 파드는 오직 클레임을 통해서만 연결되지만, 새 네임을 가진 시규 파드는 필요에 따라 리스케줄링시 해당 클레임을 넘겨받을 수 있다.

### 스테이트풀셋

노드/파드가 안정적으로 동작해야 하는 애플리케이션을 쉽게 실행할 수 있다.

### BP

- 스테이트풀셋 사용 여부는 신중하게
- 클러스터 노드가 응답하지 않는 경우, 스테이트풀셋의 일부인 파드는 자동 삭제되지 않는다.
- 파드를 강제 삭제해도 unknown 상태인 경우가 있는데... 패치해야한다.
- 리더 선출 또는 데이터 복제 확인 프로세스가 구현된 복잡한 데이터 시스템은 -> preStop hook 활용
- Operator를 통한 패키징도 고려해보자

# Chapter 17. 어드미션 컨트롤과 인가

k8s API 액세스 제어는 클러스터 보안의 핵심이자 k8s 클러스터의 전체 유저, 워크로드, 컴포넌트에 정책과 거버넌스를 부여하는 수단이다.

## 어드미션 컨트롤

어드미션 컨트롤러를 사용해서 서버 사이드에서 모범 사례를 실천해보자!

### 어드미션 컨트롤러란?

k8s API 서버 요청을 처리하는 단계 중 하나로, 인증 및 인가 이후에 요청을 받아 요청 오브젝트를 "스토리지 저장 전"에 유효성을 검사하거나 변경하는 일을 한다.

### 어드미션 컨트롤의 중요성

**정책 및 거버넌스**

다음과 가팅 비즈니스 요건을 충족하는 정책을 집행할 수 있다.

- dev 네임스페이스에서는 내부 클라우드 LB만 사용 가능
- 파드에 있는 모든 컨테이너는 리소스 리밋을 걸어야 함
- 모든 인그레스 리소스는 HTTPS만 사용

**보안**

일관된 보안태세를 적용할 수 있다.

**리소스 관리**

- FQDN 확인
- 리소스 리밋

### 어드미션 컨트롤러 타입

- standard : API 서버에 컴파일된 이후 각 k8s 릴리스에 플러그인으로 탑재되므로 API 서버가 시작될 때 구성
- dynamic : 런타임에 구성하고 HTTP 콜백을 통해 어드미션 요청을 수신하는 어드미션 웹훅

### 어드미션 웹훅

일관성과 실패 모드에 있어 이해할 필요가 있음.

### BP

- 어드미션 플러그인의 순서는 중요하지 않으며, 변경 어드미션 컨트롤러는 항상 유효성 검사 어드미션 컨트롤러보다 먼저 실행된다.
- 동일한 필드를 변형해서는 안된다 : 여러 변형 어드미션 웹훅이 동일한 필드를 변형하지 않게 해야한다.
- 변형 어드미션 웹훅은 멱등해야 한다.
- 열기/닫기 실패 : 변형/검사 부분에서 실패한다면? 어떻게 할지 정의하자
- 어드미션 웹훅은 신속하게 응답해야 한다 : 30초 타임아웃. 복잡하게 구현하지 말자
- 어드미션 웹훅 범위를 정한다 : NamespaceSelector를 통해 오셥으로 지정 가능. 항상 별도의 네임스페이스에 배포하자.
- RBAC으로 어드미션 웹훅 구성을 잠그자
- 민감한 데이터는 보내지 말라.

## 인가

인증 이후, 그리고 어드미션 이전에 처리된다.

### 인가 모듈

k8s에서 기본 제공되는 인가 모듈 :

- ABAC : 로컬 파일에 인가 정책 설정
- RBAC
- 웹훅 : 원격 REST 엔드포인트를 통해 요청을 인가
- 노드 : kubelet의 요청을 인가하는 전용 인가 모듈

### 인가 모범 사례

- 여러 컨트롤 플레인 클러스터에는 ABAC를 삼가자 : ABAC 정책은 각 컨트롤 플레인의 호스트 파일 시스템에 두고 계속 동기화해야 하므로 컨트롤 플레인 클러스터가 여럿이면 ABAC를 삼가는 것이 좋다.
- 웹훅 모듈은 사용하지 말자 : 웹훅 서비스에 연결할 수 없거나 불용 상태가 되면 전체 장애로 이어질 수 있다.
