# 14. 쿠버네티스에서 머신러닝 실행하기

### 머신러닝에 쿠버네티스를 사용하면 좋은 점
- 마이크로서비스와 클라우드 확산으로 머신러닝 모델 운영 환경이 성숙됨.  
- 쿠버네티스는 머신러닝 워크플로와 라이프사이클을 지원하기에 적합한 플랫폼임.  
- 주요 퍼블릭 및 프라이빗 클라우드에서 동일하게 동작하므로 **보편성**이 높음.  
- 오토스케일링 기능을 통해 학습에 필요한 **컴퓨팅 리소스를 자동 확장**할 수 있음.  
- 데이터 과학자는 쿠버네티스 전문지식 없이도 **셀프 서비스** 방식으로 모델을 실행할 수 있음.  
- 쿠버네티스 API 기반 환경이면 어디서든 동일하게 모델을 배포할 수 있어 **이식성**이 뛰어남.  

### 머신러닝 워크플로
- **데이터 준비** 단계에서는 스토리지 구성과 대용량 데이터셋 관리가 핵심
- **모델 개발**은 JupyterHub 등의 툴을 활용해 협업과 실험을 수행  
- **훈련** 단계는 스케줄링, 하드웨어 자원, 네트워킹 등 쿠버네티스 기능이 총동원됨.  
- **제공** 단계에서는 훈련된 모델이 서비스 요청을 받아 추론을 수행

### 클러스터 관리자가 고려해야 할 사항

#### 모델 훈련
- 모델 훈련은 CPU와 GPU 리소스를 집중적으로 사용함.  
- 리소스를 늘릴수록 훈련 속도도 빨라짐.  
- 분산 훈련 전에는 다중 GPU가 장착된 단일 VM을 사용하는 것이 효율적임.  
- 하이퍼파라미터 튜닝을 반복 실행해 최적의 모델을 찾는 과정이 필요함.  

#### 분산 훈련
- 분산 훈련은 아직 최적화 초기 단계임.  
- GPU 4개 장착 서버 2대보다 GPU 8개가 장착된 서버 1대에서 훈련하는 편이 대부분 더 빠름.  
- 분산 훈련이 필요한 경우는 **모델이 단일 머신 메모리에 맞지 않을 때**뿐임.  

#### 특수 하드웨어
- GPU 등 특수 하드웨어는 디바이스 플러그인을 통해 스케줄링 가능함.  
- 대부분의 플러그인은 **데몬셋**으로 실행되어 각 노드에서 리소스를 광고함.  
- 쿠버네티스는 모르는 리소스에 대해 결정하지 않기 때문에, GPU 활용률이 완전하지 않을 수 있음.  
- 향후 플러그인 개발로 이러한 제약은 개선될 것으로 예상됨.  

#### 라이브러리, 드라이버, 커널 모듈
- 특수 하드웨어 접근에는 전용 라이브러리, 드라이버, 커널 모듈이 필요함.  
- 컨테이너 런타임에서 호스트 버전과 일치해야 하며, NVIDIA 도커 같은 런타임으로 관리 가능함.  
- 특권 컨테이너가 필요할 수도 있으며, 디바이스 플러그인을 통해 손쉽게 설치 및 검증 가능함.  

#### 스토리지
- 훈련 중 데이터셋은 각 노드에서 접근 가능해야 함.  
- 수백 MB~GB 규모는 **블록 스토리지**, 수십~수백 TB 규모는 **오브젝트 스토리지**가 적합함.  
- 훈련 과정에서 생성되는 **체크포인트**와 **저장 모델**은 ReadWriteMany 지원 PV에 저장함.  
- 데이터 일관성을 위해 퍼시스턴트볼륨(PV) 구성 시 스토리지 타입을 신중히 선택해야 함.  

#### 네트워킹
- 분산 훈련 시 네트워크 대역폭이 훈련 성능에 직접적인 영향을 미침.  
- 높은 대역폭이 필요하면 **인피니밴드(InfiniBand)** 사용을 검토함.  
- 커널 수준 네트워크 병목이 발생할 경우 **RDMA(Remote Direct Memory Access)** 로 최적화 가능

#### 전용 프로토콜
- 병목을 줄이고 GPU 간 직접 통신을 가능하게 하는 전용 프로토콜 사용이 중요함.  
- **MPI(Message Passing Interface)** 는 분산 프로세스 간 데이터 전송을 표준화함.  
- **NCCL(NVIDIA Collective Communications Library)** 은 멀티 GPU 통신을 위한 라이브러리로 활용됨.  

| 모범사례 생략!

# 15. 고수준 애플리케이션 패턴 구축

### 고수준 추상화의 필요성
- 쿠버네티스는 분산 애플리케이션 배포를 단순화하지만, 개발자는 여전히 복잡한 개념을 학습해야 함.  
- 대규모 조직에서는 애플리케이션 구성과 배포 방식을 표준화하여 모든 팀이 동일한 **운영 모범 사례**를 따르게 하는 것이 효율적  
- 고수준 추상화는 개발자가 복잡한 인프라를 몰라도 일관된 품질의 애플리케이션을 배포할 수 있도록 도와줌.  
- 다만, 세부 제어가 어려워지는 **월드 가든(walled garden)** 위험이 있으므로 균형 잡힌 설계가 필요함.  

### 고수준 추상화 개발 방식
- 고수준의 개발 방식은 두 가지로 구분됨.  
  1. **쿠버네티스를 래핑(wrapping)** 하여 완전히 숨기는 방식  
  2. **쿠버네티스 자체를 확장(extension)** 하는 방식  
- 첫 번째 방식은 사용 편의성이 중요할 때 적합하며, 머신러닝 같은 통합 환경 구축에 적합함.  
- 두 번째 방식은 애플리케이션 개발처럼 범위가 넓고 다양한 요구가 있는 분야에 더 적합함.  
- 확장 방식을 사용하면 쿠버네티스 API와 기존 툴 체계를 그대로 활용할 수 있어 **유연성과 호환성**이 높음.  

### 쿠버네티스 확장

#### 쿠버네티스 클러스터 확장
- 쿠버네티스는 다양한 확장 포인트를 제공하며, **사이드카(sidecar)** 와 **어드미션 컨트롤러(admission controller)** 가 대표적임.  
- 사이드카는 메인 애플리케이션 옆에서 보조 기능을 수행하는 컨테이너로, 서비스 메시(mTLS 인증 등) 기능을 추가할 때 자주 사용됨.  
- **어드미션 컨트롤러**는 쿠버네티스 API 요청을 가로채 리소스의 유효성을 검사하거나, 파드 생성 시 자동으로 사이드카를 추가함.  
- 필요에 따라 특정 **애너테이션**을 통해 예외(백도어)를 허용할 수도 있음.  
- **CRD(Custom Resource Definition)** 를 사용하면 새로운 리소스 타입을 정의해 쿠버네티스 오브젝트를 고수준으로 추상화할 수 있음.  

#### 쿠버네티스 UX 확장
- 커맨드라인 경험을 개선하기 위해 **kubectl 플러그인**을 사용함.  
- 새로운 리소스를 이해하고 관리하기 위한 UX를 자유롭게 정의할 수 있음.  
- 기존 툴 사용 경험을 그대로 유지하면서 새로운 기능을 제공할 수 있어 학습 부담이 줄어듦.  
- GUI 환경 구축 시 **Headlamp** 같은 오픈 소스 툴을 사용해 웹 기반 인터페이스를 쉽게 구성할 수 있음.  

#### 컨테이너화 개발 간소화
- 쿠버네티스에 배포하려면 애플리케이션을 컨테이너화해야 함.  
- **Draft**, **Skaffold**, **Paketo** 같은 툴을 사용하면 Dockerfile 생성과 빌드 과정을 자동화할 수 있음.  
- 이런 툴은 개발자가 언어나 런타임에 맞는 컨테이너를 빠르게 빌드하고 테스트하도록 지원함.  

#### Push-to-deploy 환경 구축
- **push-to-deploy**는 코드 푸시만으로 자동 빌드·테스트·배포가 진행되는 환경을 뜻함.  
- GitHub Actions, Azure DevOps, CI/CD 파이프라인을 결합해 구현 가능 
- 컨테이너 이미지가 레지스트리에 푸시되면 GitOps를 통해 자동으로 클러스터에 반영됨.  
- 개발자는 단순히 코드만 푸시해도 배포가 자동화되는 생산적인 환경을 누릴 수 있음.  

### 플랫폼 구축 시 설계 고려 사항

#### 컨테이너 이미지로 익스포트하는 기능
- 개발자가 단순히 코드를 제공하면 플랫폼이 대신 컨테이너화를 수행할 수 있도록 설계할 필요가 있음.  
- 단, 필요 시 개발자가 직접 컨테이너 이미지를 수정하거나 런타임을 교체할 수 있는 **확장성**을 제공해야 함.  
- 플랫폼은 완전한 컨테이너 이미지로 애플리케이션을 내보낼 수 있도록 지원해야 함.  
- 이를 통해 사용자는 플랫폼에 의존하지 않고 점진적으로 저수준 인프라를 학습해 나갈 수 있음.  

#### 기존 서비스 및 서비스 디스커버리 지원
- 플랫폼은 외부 서비스 및 기존 시스템과의 통합을 고려해야 함.  
- **쿠버네티스 서비스**와 **DNS 기반 서비스 디스커버리**를 활용하면 재구현 없이 상호 연동 가능함.  
- **바퀴를 다시 발명하지 말고, 쿠버네티스의 기본 메커니즘을 적극적으로 활용해야 함** 
- 플랫폼이 고립된 월드 가든이 되지 않도록 개방성과 호환성을 확보해야 함.  
