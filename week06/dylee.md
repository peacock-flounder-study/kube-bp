# 11. 클러스터 정책과 거버넌스
## 1. 정책의 변별성

- 정책과 거버넌스로 쿠버네티스 리소스 스펙의 필드값을 제한해 클러스터에 반영하자

## 2. 클라우드 네이티브 정책 엔진

- OPA: 개방형 정책 에이전트로 유연하고 가벼움 → 이 중 게이트키퍼가 쿠버네티스 거버넌스 툴의 대표적인 구현체

## 3. 게이트키퍼

- 정책 템플릿에 정책을 작성해서, 게이트키퍼(admission webhook)로 클러스터 정책과 거버넌스를 구현하자
- 이때 게이트키퍼는 OPA constraints framework로 CRD 기반의 정책을 적용함
    - CRD: Custom Resource Definition → 새로운 리소스 타입을 정의해서 사용
    - 제약조건: k8s 리소스 스펙의 특정 field 또는 값에 적용하는 제약
    - Rego: OPA 네이티브 쿼리 언어로 게이트키퍼는 제약조건 템플릿에 Rego 저장
    - 제약조건 템플릿: 정책 공유, 재사용 가능한 CRD

### 적용 방식

1. CRD 메타데이터 정보 + validation field에 입력 파라미터와 관련 타입 + target field에 Rego를 기재해서ConstraintTemplate.yaml 생성(제약조건 템플릿 생성) 
2. 제약조건 리소스 생성해서 제약조건 템플릿과 매핑
3. Config 리소스로 Gatekeeper가 클러스터 내부의 다른 리소스를 OPA 엔진의 캐시에 복제해 규칙 평가
4. 게이트키퍼는 어떤 리소스가 지정된 정책을 위반하면 → 클러스터 유저에게 즉시 피드백(Admission Webhook)

# 12. 멀티클러스터 관리
## 1. 멀티클러스터의 필요성

- cascading failure 상황을 예방하고, 보안이 중요한 특수한 워크로드의 경우 데이터의 위치, 격리, 보안에 대한 규제 요건을 지키기 위해 멀티클러스터를 도입함
- 또한 전 세계에 배포되는 애플리케이션, 특수 워크로드(고성능 컴퓨팅, 머신러닝, 그리드 컴퓨팅)의 경우 워크로드를 리전별로 분리시켜 멀티 클러스터로 적용하는 것을 권장
- 하지만 쿠버네티스는 클러스터 안에서 실행 중인 모든 workload와 동일한 api 서버를 공유하므로 하드 멀티테넌시를 제공하지 않음(하나의 클러스터를 ns로 나누는 소프트 멀티테넌시 기능은 제공)
- 따라서 멀티 클러스터는 단일 클러스터에 비해 통합률이 낮아 관리하는 것이 쉽지 않다

## 2. 멀티클러스터 설계 문제

- 멀티클러스터 설계 시도 시 고려해야 하는 지점 → 데이터 복제, 서비스 디스커버리, 네트워크 라우팅, 운영 관리, 지속적 배포
1. 데이터 복제: 여러 지역과 멀티클러스터에 워크로드를 배포 시 서비스 실행 위치, 복제 전략이 필요함 
    
    → 리전 간 최종 일관성, 레이턴시 등을 고려해야 함 → 클라우드 서비스에서 제공하는 DB를 사용하자!
    
2. 서비스 디스커버리: 다른 클러스터끼리는 서비스 디스커버리 x → hashcope consul, istio등을 사용하자
3. 네트워크 라우팅: 다른 클러스터 간의 egress(외부로 나가는 트래픽)과 ingress 트래픽을 라우팅 하는 방법에 대한 고민 필요
4. 운영 관리: dependency가 높은 어플리케이션은 동일한 클러스터에서 실행하고, Terraform 으로 여러 클러스터의 상태를 자동으로 일관되게 관리해 운영 부담을 줄이자
5. 지속적 배포: 다수의 api endpoint를 처리하는 CD 전략이 필요

## 3. 멀티클러스터 배포 관리

- Terraform같은 IaC툴과 클러스터 API로 클러스터 수준에서 선언형으로 배포 파이프라인을 구축해 클러스터 배포/운영을 자동화 하자

## 4. 배포와 관리 패턴

- IaS 구현체인 쿠버네티스 오퍼레이터를 사용해서 애플리케이션과 서비스의 배포를 클러스터 수준에서 추상화 하여 관리하자
    
    ex) 오퍼레이터 패턴을 적용해 프로메테우스 오퍼레이터로 클러스터 관리 자동화 하기
    
    → CRD와 커스텀 컨트롤러로 멀티클러스터에서 자동화한 운영 태스크 체계를 구축할 수 있음
    
    - CRD: 유저가 정의한 API를 기반으로 k8s API 확장할 수 있게 해주는 오브젝트(커스텀 리소스 정의)
    - 커스텀 컨트롤러: 쿠버네티스 API 오브젝트(ns, deployment, pods,CRD..)에서 이벤트를 관찰하고, CRD를 선언형 방식으로 빌드 가능

## 5. 깃옵스로 클러스터를 관리하는 방식

- git repository와 cluster를 동기화되도록 설정 → 멀티클러스터의 일관성을 유지하고, 클러스터 마다 선언적으로 상태 관리
- Weaveworks Flux, ArgoCD 등

## 6. 멀티 클러스터 관리 툴

- kubectx와 kubens로 멀티 클러스터에서 여러 컨텍스트와 네임스페이스를 관리하자
- 관리 툴: 랜처, OCM, 가드너

# 13. 외부 서비스와 쿠버네티스 통합
## 1. 쿠버네티스로 서비스 임포트

- 쿠버네티스와 외부 서비스를 연결하는 가장 일반적인 패턴은 클러스터 외부에 존재하는 서비스를 쿠버네티스 서비스가 소비하는 것
- 쿠버네티스와 외부 서비스를 연결하고 → 외부 서비스를 쿠버네티스 내부의 DNS에서 검색 되도록 설정해야 함
    - 설정 방법
    1. 셀렉터리스 서비스
        - selector가 없는 서비스 생성 → service와 같은 이름을 가진 endpoint를 생성하여 외부 서비스의 실제 ip 주소와 port적음 →
        - 이제 pod가 내부 cluster service이름으로 접속하면 이 요청은 CoreDNS로 전성되고, DNS 서버는 해당 service를 찾아 endpoint 리소스를 확인해 등록된 ip 주소를 반환하여 클러스터 내부의 pod와 외부 서비스 연결
    2. CNAME 기반 서비스
        - DNS 네임을 가진 외부 서비스와 쿠버네티스의 서비스를 연결
        - Service에 `spce.type: ExternalName` , `spec.externalName: database.myco.com`
    3. 액티브 컨트롤러 방식
        - 안정적인 DNS, IP 주소가 존재하지 않는 경우 control loop로 인프라를 쿼리 → 이 IP 주소로 service의 endpoint를 채움 → k8s dns 서버와 kube-proxy를 프로그래밍 해 외부 서비스 트래픽을 로드 밸런싱

## 2. 쿠버네티스에서 서비스 익스포트

- 쿠버네티스에 있는 서비스를 기존 환경으로 export 해야 하는 경우 기존 어플리케이션과 쿠버네티스 파드 사이의 라우팅을 설정하는 것이 핵심

### 1. 내부 로드 밸런서로 서비스 익스포트

- 내부 로드 밸런서를 거쳐 서비스를 export해 클러스터 외부의 가상 네트워크에서 라우팅 가능한 IP 주소를 확보해서 활용하자

### 2. NodePort로 서비스 익스포트

- NodePort(30000~30999)로 서비스를 export

### 3. 외부 서비스와 쿠버네티스 통합

- 어플리케이션 실행 머신을 쿠버네티스 클러스터의 service discovery와 네트워킹 매커니즘에 직접 통합
    
    → 하지만 외부 서비스 전용 container runtime을 추가로 설치해야 해 복잡해짐
    

## 3.  쿠버네티스 간 서비스 공유

- 상이한 쿠버네티스 클러스터 간 서비스 연결 방법?
    1. 네트워크 트래픽을 흘릴 첫 번째 쿠버네티스 클러스터 서비스 표출 → 이 IP 주소를 다른 클러스터에 연동(소규모 서비스에 적합)
    2. 클러스터 데몬을 만들어 양쪽의 클러스터에서 실행 → 첫 번째 클러스터에 export-service관련 서비스 감지 → 셀렉터리스 서비스를 거쳐 두 번째 클러스터로 임포트

## 4. 서드파티 룰

- 서비스 메시를 활용해 보자

   
