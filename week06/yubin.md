# 11. 클러스터 정책과 거버넌스

### 정책과 거버넌스의 중요성
- 쿠버네티스가 조직 내 핵심 인프라로 자리 잡으면서, 정책 기반 관리의 필요성이 커짐.
- 규제가 강한 산업(의료, 금융 등)은 특히 **컴플라이언스 준수**와 **운영 일관성** 확보가 중요함
- 정책은 리소스 생성과 변경을 제어하여 클러스터가 정의된 기준을 벗어나지 않도록 함.

### 정책의 변별성
- 쿠버네티스의 모든 리소스 스펙은 이미 일종의 정책을 포함함.
- 네트워크 정책, 파드 보안 정책 등은 런타임 수준에서 작동하지만, 거버넌스 정책은 리소스 정의 자체를 제한.
- 목표는 **정책을 준수한 리소스만 클러스터에 반영**되게 하는 것
- 즉 “어떤 리소스가, 어떤 값으로 구성될 수 있는가”를 결정하는 것이 핵심.

### 클라우드 네이티브 정책 엔진
- 다양한 요구사항을 충족하려면 유연하고 경량의 정책 엔진이 필요.
- OPA(Open Policy Agent)는 쿠버네티스뿐 아니라 클라우드 전반에서 활용되는 범용 정책 엔진.
- OPA를 바탕으로 한 대표 구현체 Gatekeeper는 정책 거버넌스의 사실상 표준으로 자리 잡음.
- 정책 정의와 집행을 분리하고, 클러스터 전역의 리소스를 감사·검증할 수 있음

### Gatekeeper 개요
- Admission Webhook 기반의 정책 제어 도구로, 쿠버네티스 CRD를 통해 선언적 정책 정의 가능.
- OPA의 Constraint Framework 위에서 동작하며, 템플릿 기반 재사용 구조를 제공.
- 정책 템플릿은 클러스터 전체에서 공유 가능
- 주기적인 감사(audit) 기능을 제공하여 위반된 리소스를 탐지.
- 기존 OPA 정책을 그대로 게이트키퍼에 이식할 수도 있음.

### 정책 예제
- 서비스가 외부 인터넷에 노출되면 안 된다.
- 신뢰된 컨테이너 레지스트리에서 생성된 이미지만 허용한다.
- 모든 컨테이너는 **리소스 리밋(resource limit)**을 설정해야 한다.
- 인그레스 호스트네임은 중복될 수 없다.
- 인그레스는 반드시 **HTTPS만 허용**

### 집행 액션과 감사 적용
- 정책 위반 시 동작은 `enforcementAction` 설정으로 제어함.
  - **deny**: 위반 리소스 생성 거부, 에러 로그 기록.
  - **warn**: 리소스는 생성되지만 경고 메시지 출력.
  - **dryrun**: 리소스 생성 후 위반 내용만 감사 로그에 기록.
- 초기 도입 시 `warn` 또는 `dryrun`으로 시작하고 점진적으로 `deny`로 전환하는 것이 안전.
- 게이트키퍼는 주기적으로 정책과 리소스를 비교하여 위반 항목을 탐지.
- 감사 결과는 Constraint 리소스의 `status` 필드에서 즉시 확인 가능.

### 모범 사례
- 정책은 민감한 네임스페이스부터 점진적으로 도입할 것
- 시크릿 등 민감한 데이터는 정책 캐시에 저장하지 말자
- 정책 변경 시 CI/CD 환경에서 사전 테스트(`gator` 등)를 수행
- 가능한 한 정책을 **명확하고 단순하게 유지**하기 


# 12. 멀티클러스터 관리

### 멀티클러스터의 필요성
- 대부분의 조직은 개발·스테이징·프로덕션 환경을 분리하여 운영함.
- 쿠버네티스 네임스페이스로 논리적 격리는 가능하지만, 보안·규모·운영 복잡성 면에서 한계가 있음 → **클러스터 자체를 분리**하는 멀티클러스터 아키텍처가 필요

#### 폭발 반경
- 단일 클러스터에서는 장애 발생 시 전체 서비스가 영향을 받음.
- 여러 클러스터로 분산하면 장애의 영향 범위를 줄여 연쇄 실패를 방지할 수 있음.
- 반면 관리 포인트가 늘어나므로 자동화가 필수.

#### 컴플라이언스
- 금융, 의료 등 규제 산업에서는 클러스터를 분리해 데이터 및 보안 정책을 개별 관리하는 것이 유리.
- 특정 클러스터는 감사·추적·보안 로그용 등 **규제 목적에 특화된 구성**으로 운영.

#### 보안과 멀티테넌시
- 네임스페이스 기반 멀티테넌시는 완전한 격리를 보장하지 않음.
- 하드 멀티테넌시는 비신뢰 환경(SaaS, 퍼블릭 멀티유저 플랫폼)에서만 필수.
- 내부 환경이라면 소프트 멀티테넌시로도 충분한 경우가 많음.

#### 리전 기반 워크로드
- 글로벌 서비스는 리전별 트래픽 처리와 지연시간 최소화를 위해 **리전 단위 클러스터 운영**이 필요.
- 이런 경우 클러스터 페더레이션이나 멀티클러스터 서비스 API 활용을 검토할 수 있음.

### 멀티클러스터 설계 문제
멀티클러스터 환경을 설계하면 복잡도와 고려사항이 급격히 증가한다.

#### 데이터 복제
- 리전 간 데이터 동기화와 일관성 유지가 핵심.
- DB 수준에서 복제를 처리하거나, 클라우드 관리형 DB(Cloud Spanner, Cosmos DB 등)를 활용.

#### 서비스 디스커버리
- 각 클러스터는 독립된 DNS/레지스트리를 가짐.
- **Consul, Istio, Linkerd, Cilium** 등을 사용하면 클러스터 간 서비스 탐색을 통합할 수 있음.

#### 네트워크 라우팅
- 인그레스는 클러스터 단위로 동작하므로, **클러스터 간 트래픽 라우팅 설계**가 필요.
- 디펜던시가 강한 애플리케이션은 동일 클러스터에 두어 레이턴시를 최소화.

#### 운영 관리
- 클러스터 수가 늘면 관리 복잡도가 급격히 증가.
- Terraform 같은 **IaC 툴**로 인프라 배포를 표준화하고, 애드온(로깅·보안·모니터링)을 자동화해야 함.

#### 지속적 배포
- 다수의 API 엔드포인트를 동시에 다뤄야 하므로, 배포 파이프라인의 복잡도가 커짐.
- GitOps 기반 접근이나 클러스터 단위 CD 파이프라인을 검토할 것.

### 멀티클러스터 배포 관리
- IaC 기반 자동화는 멀티클러스터 운영의 핵심.
- **Terraform, Kubespray, Kops** 등으로 반복 가능한 배포 파이프라인을 구축.
- **Cluster API**를 이용하면 쿠버네티스 리소스처럼 클러스터 자체를 선언적으로 정의·관리 가능.
- 초기 단계지만 향후 멀티클러스터 자동화의 중심 프로젝트로 주목됨.

### 배포와 관리 패턴
#### 오퍼레이터 패턴
- **Operator**는 쿠버네티스 API를 확장하여 애플리케이션을 클러스터 수준에서 제어하는 방식.
- e.g. 프로메테우스 오퍼레이터를 사용하면 CRD 기반으로 배포, 서비스, 규칙, 알림을 모두 관리 가능.
- 새로운 CRD와 **컨트롤러**를 통해 운영 태스크를 자동화하고, 인프라를 코드처럼 제어.

#### 관리 효율화
- 클러스터가 늘어날수록 운영 복잡도가 커지므로 핵심 운영 태스크를 오퍼레이터로 이관.
- 모니터링, 배포, 보안 설정 등 반복 작업을 자동화하여 운영 일관성을 확보.

### 모범 사례
- 폭발 반경을 최소화하도록 클러스터를 설계
- 규제 요건, 보안 수준, 리전 분산을 기준으로 클러스터를 구분
- IaC와 오퍼레이터 패턴을 통해 관리 자동화를 구현
- 서비스 디스커버리 및 라우팅 전략을 설계 초기부터 반영
- 클러스터 간 통신 구조는 항상 **관측성과 복원력**을 기준으로 검토

# 13. 외부 서비스와 쿠버네티스 통합

### 쿠버네티스로 서비스 임포트
- 쿠버네티스는 새로운 애플리케이션뿐 아니라 **기존 레거시 서비스와의 통합 인프라**로도 활용됨.
- 데이터베이스나 기존 API 등 외부 리소스를 쿠버네티스 클러스터 내부 서비스처럼 접근할 수 있도록 구성할 수 있다.
- 핵심은 외부 서비스를 “마치 처음부터 쿠버네티스 서비스였던 것처럼” 보이게 만드는 것.

#### 네트워크 연결 전제
- 쿠버네티스 파드와 외부 리소스 간 네트워크 통신이 가능한 상태여야 함.
- 클라우드에서는 가상 네트워크(VNet, VPC)를 온프레미스 네트워크와 **피어링(peering)** 하여 통신을 구성.

#### 셀렉터리스(Selector-less) 서비스
- **셀렉터가 없는 서비스**를 정의해 외부 리소스의 IP 주소를 직접 엔드포인트로 지정.
- 쿠버네티스 DNS 서버는 해당 서비스를 조회할 때 외부 IP로 변환해 응답.
- 주로 고정 IP를 가진 외부 리소스(온프레미스 DB 등)에 적합.

#### CNAME 기반 서비스
- 외부 서비스가 **고정 IP가 아닌 안정적인 DNS 이름**만 갖는 경우 사용.
- 서비스의 CNAME 레코드를 클러스터 내부 DNS에 등록하여 동일 네임으로 접근 가능.
- 네임스페이스 단위로 정의되므로, `database`라는 이름을 각 환경(e.g. canary, production)에 다르게 매핑 가능.

#### 액티브 컨트롤러 방식
- IP나 DNS가 고정되지 않은 환경에서는 앞선 두 방식이 불가능.
- 이 경우 **컨트롤러 루프**를 만들어 외부 리소스 상태를 주기적으로 조회하고, 엔드포인트 리소스를 동적으로 갱신.
- 쿠버네티스 DNS와 kube-proxy를 프로그래밍해 **외부 트래픽을 올바르게 로드밸런싱**할 수 있음.

### 쿠버네티스에서 서비스 익스포트
- 이번에는 반대로, **쿠버네티스 내부의 서비스를 외부 환경으로 내보내는(export)** 방식.
- 내부 레거시 애플리케이션이나 외부 시스템이 클러스터 내부 API나 파드에 접근해야 하는 경우에 사용.
- 핵심은 "**기존 환경에서 쿠버네티스 서비스로 라우팅이 가능하도록** 만드는 것."

#### 내부 로드 밸런서
- 클라우드 환경의 **내부 로드 밸런서(Internal Load Balancer)** 를 이용해 클러스터 내부 서비스를 노출.
- 외부 트래픽을 특정 서브넷 내부에서만 접근 가능하도록 제한 가능.
- 외부 IP를 노출하지 않고, **보안성을 유지하면서 트래픽을 익스포트**할 수 있음.

#### NodePort 방식
- 온프레미스 환경에서는 클라우드 로드 밸런서를 사용할 수 없으므로 NodePort 활용.
- 노드 IP와 포트를 통해 외부 시스템에서 직접 접근 가능.
- 단, 포트 관리 및 방화벽 설정이 필요.

#### 외부 서버와 쿠버네티스 통합
- 고급 통합 시나리오에서는 **외부 머신을 쿠버네티스 네트워크에 직접 참여시킬 수도 있음.**
- 해당 머신에서 kubelet을 실행하되, 스케줄링은 비활성화하고 kube-proxy를 통해 클러스터 DNS에 연동.
- 이렇게 하면 외부 애플리케이션도 쿠버네티스 서비스 디스커버리를 그대로 사용 가능.
- 단, 침습적이고 복잡하므로 관리형 환경에서는 제한적.

### 쿠버네티스 간 서비스 공유
- 다른 리전이나 팀에서 운영 중인 **서로 다른 클러스터 간 서비스 연동**이 필요한 경우.
- 한 클러스터의 서비스를 외부로 익스포트(Internal LB 등) 하고, 다른 클러스터에서는 셀렉터리스 서비스로 임포트
- 이 방식으로 두 클러스터 간 서비스 디스커버리와 통신이 가능함

#### 자동화 방식
- 클러스터 간 통신을 수동으로 구성하면 유지보수가 어렵기 때문에, 클러스터 데몬을 활용.
- 데몬은 특정 어노테이션이 붙은 서비스를 감시하고,
  - 첫 번째 클러스터에서 발견되면 두 번째 클러스터로 자동 임포트,
  - 반대로 더 이상 존재하지 않으면 자동 삭제.
- 이렇게 하면 각 리전 또는 팀별 클러스터 간 **동적 서비스 연동**이 가능.

### 모범 사례
- 외부 리소스와의 통합은 **DNS 중심 설계**로 일관성 있게 구성할 것
- IP 기반 접근은 단기적, CNAME 기반 접근은 장기적 확장성에 유리
- 액티브 컨트롤러는 복잡하지만, 자동화 수준이 높은 환경에 적합
- 서비스 익스포트 시에는 내부 트래픽 범위를 명확히 제한하고, 보안을 최우선으로 고려
- 여러 클러스터 간 통합은 가능한 한 **자동화(컨트롤러/데몬 기반)** 로 처리하자