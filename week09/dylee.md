# 18. 깃옵스와 배포
## 1. 깃옵스란?

- git repository를 source로 해서 모든 cluster resource가 git으로 동기화 되는 것 → k8s manifest를 업데이트 하면 해당 변경 사항이 실제로 클러스터에 자동 반영됨 → 멀티클러스터를 일관성 있게 관리 가능
    - workflow
        - 코드 커밋 → 깃헙 리포지터리 → CI 빌드 → 도커 레지스트리 → 깃옵스 툴 → 쿠버네티스 클러스터
        - 선언형 구성, 구성 버저닝, 불변 구성, 지속적인 상태 조정이라는 4가지 원칙을 준수해서 workflow를 구축하자

## 2. 깃옵스가 필요한 이유

- 모든 구성이 선언형 YAML 파일로 작성되어 깃으로 관리되기 때문에 깃 히스토리를 통해 변경 사항을 쉽게 감시 가능하고, 버전 관리가 쉬우며, 변경 사항에 대한 추적이 쉬워 보안에 좋으며, 클러스터와 깃의 상태가 동기화 되기 때문에 롤백 및 일관된 클러스터 상태 유지가 쉽다.

## 3. 깃옵스 리포지터리 구조

- 상황에 따라 단일 리포지터리, 팀별 리포지터리, 애플리케이션별 리포지터리, 환경별 브랜치 전략 중 하나를 선택하자

## 4. 시크릿 관리

- 실드 시크릿(kubeseal), 시크릿 관리 툴(KMS)로 시크릿을 관리하자

# 19. 보안
## 1. 클러스터 보안

- control plane이 api를 통해 외부에 노출되므로 클러스터 access 관련 액션을 정하고 제한해야 한다

### 1. etcd 액세스

- 쿠버네티스 디폴트 스토리지 시스템
- k8s api 서버만 액세스, 네트워크 통신이 가능하게 설정해야 함

### 2. 인증

- kubeconfig를 생성할 때는 토큰, 인증서 등 인증 수단을 통해 인증된 유저만 생성, 배포가 가능 하도록 하자

### 3. 인가

- RBAC: 어떤 리소스에서 무슨 작업을 할 수 있는지 제한하는 쿠버네티스 기본 인가 툴
- RBAC 리소스로 필요한 작업만 최소한으로 액세스 하도록 제한하자

### 4. TLS

- k8s는 기본적으로 TLS 보안이 적용된 API 엔드포인트를 기본 제공함

### 5. kubelet과 클라우드 메타데이터 액세스

- kubelet: 노드와 노드에서 실행 중인 파드를 관리하는 컴포넌트로 노드당 하나씩 있음
- kubelet Api는 기본적으로 인증이 되어 있지 않음 → 인증, 인가 기능을 활성화 해야 함

### 6. 시크릿

- 암호화 프로바이더를 설정한 후 쿠버네티스 리소스를 etcd에 저장하자

### 7. 로깅과 감사

- 쿠버네티스 api 서버에 로깅 기능을 활성화 하고, 감사 로그 트리거를 구성하자

### 8. 클러스터 보안 태세 툴

- Kubescape 툴 등을 주기적으로 실행해 클러스터와 배포된 리소스의 보안 태세를 파악하자

## 2. 워크로드 컨테이너 보안

### 1. 파드 시큐리티 어드미션

- 파드를 구성할 때 보안에 민감한 모든 컴포넌트를 구성/관리하고 네임스페이스나 클러스터 수준에서 즉시 활용 가능한 모범 사례를 적용할 수 있음

### 2. Seccomp, Apparmor, SELinux

- Seccomp: 컨테이너에서 유입된 시스템 호출을 제한하는 시스템 호출 필터링 프로파일 생성. Seccomp 디폴트 프로파일링을 활성화해서 사용하자
- Apparmor, SELinux: 컨테이너별로 필요한 액세스 제어를 세밀하게 구성할 수 있는 리눅스 커널의 보안 모듈

### 3. 어드미션 컨트롤러

- 워크로드 보안의 핵심 요소

### 4. 오퍼레이터

- 쿠버네티스 API를 통해 애플리케이션 단위로 조정이 필요한 워크로드에 커스텀 리소스를 제공하는 컨트롤러

### 5. 네트워크 정책

- network provider가 네트워크 정책 리소스를 runtime에 구현하는지 체크 필수
- 네트워크 정책으로 cluster 또는 namespace 단위로 정책을 수립하자

### 6. 런타임 보안

- 기본적으로 리눅스 cgroup를 활용하는 containerd 또는 CRI-O를 제공하지만 Kata, gvisor 등의 컨테이너 런타임으로 워크로드 상황에 맞게 보안을 고려한 컨테이너 런타임을 선정하자
- RuntimeClass field로 여러 컨테이너 런타임 사용 가능함
- 컨테이너 런타임 로깅 → Falco

## 3. 코드 보안

### 1. 넌루트와 무배포 컨테이너

- 컨테이너 빌드 파일의 일부로 non-root유저를 지정해 애플리케이션 프로세스가 루트 유저로 실행되지 않도록 구성하고
- 무배포 컨테이너와 스크래치 컨테이너 같은 툴을 사용해 작은 베이스 컨테이너 이미지를 사용하여 공격 표면을 줄이자

### 2. 컨테이너 취약점 탐색

- 컨테이너 취약점을 스캔하는 오픈소스를 활용해 컨테이너 배포 여부를 결정하는데 참고하자

### 3. 코드 리포지터리 보안

- SLSA, OpenSSF 스코어카드로 소스코드 리포지터리의 보안을 개선하자
