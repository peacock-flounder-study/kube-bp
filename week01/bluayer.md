# Chapter 01. 기본 서비스 설치

## 구성 파일 관리

선언을 통해 구성 관리 -> 명령형 방식은 애플리케이션에서 발생한 문제를 이해하거나 재현하기 쉽지 않음.

쿠버네티스에서는 JSON, YAML 둘 다 사용

쿠버네티스 구성을 git으로 관리하며, 버전 관리에 드는 노력만큼 코드 리뷰에도 정성을 쏟아야 한다. (상태를 정확하게 관리하기 위해서)

저널 애플리케이션의 파일 레이아웃 예제 :

```
journal/
  frontend/
  redis/
  fileserver/
```

## 디플로이먼트를 이용한 복제 서비스 생성

### 이미지 관리 모범 사례

이미지 빌드 프로세스는 공급망 공격(신뢰할 수 있는 소스의 디펜던시에 해커가 악의적인 코드나 바이너리를 삽입하여 애플리케이션에 집어넣는 행휘)에 취약하다.

이미지 네이밍 모범 사례 : immutable tags, 이미지가 빌드된 커밋의 semantic version과 SHA hash를 조합하기 (v1.0.1-bfeda01f)

### 애플리케이션 레플리카 생성

ReplicaSet : containerized 특정 애플리케이션을 직접 복제하기 위해 만든 쿠버네티스 리소스. 하지만, 이걸 직접 쓰기보다 Deployment를 대신 사용하는 게 좋음
**Deployment** : ReplicaSet의 복제, versioning, staged rollout을 지원. 애플리케이션의 버전 변경을 매끄럽게 도움

레이블을 활용한 구별(app:front-end)

YAML 파일 곳곳에 있는 주석 👍

- requests(요청) : 애플리케이션을 실행하는 호스트 머신에 예약한 리소스
- limits(리밋) : 컨테이너가 사용할 수 있는 최대 리소스

예전에 읽었던 글 : https://itchain.wordpress.com/2018/05/16/kubernetes-resource-request-limit/

클러스터의 콘텐츠와 실제로 소스 코드에 정의한 콘텐츠가 서로 정확히 일치하는 그림이 가장 이상적 -> **GitOps**를 이용해 Ci/CD 시스템을 자동화하기

***참고 (MacOS)***
colima 설치  > minikube 설치 후 실습 진행

## HTTP 트래픽을 처리하는 외부 인그레스 설치

애플리케이션을 외부에 표출하여 트래픽이 들어오게 하려면 외부 IP 주소를 제공하는 서비스와 LB가 필요하다.

1. TCP/UDP 트래픽을 로드 밸런싱 하는 **Service**
2. HTTP 경로와 호스트 기반의 요청을 지능적으로 라우팅하도록 LB하는 **Ingress** : 인그레스 컨트롤러 컨테이너가 필요. CSP 혹은 OSS 중 구현체 선택.

***마이크로서비스에 HTTP로 액세스하는 방식을 두고 논란이 많았고, k8s용 Gateway API가 개발되었다. Gateway API(GatewayClass)는 k8s 익스텐션이므로 사용하려면 클러스터에 추가 컴포넌트를 설치해야 한다.***

## 컨피그맵으로 애플리케이션 구성

디플로이먼트에 작성

1. 동일한 애플리케이션 바이너리라도 구성을 달리 적용해야 하는 경우가 있다.
2. 신규 기능을 켜고 끄는 구조에서 이미 서비스 중인 기능을 수정하려면 다시 빌드해야 함.
3. 기능별 롤아웃, 롤백

컨피그맵 자체를 바꾼다고 기존 파드가 저절로 업데이트 되지 않으며, 파드를 재시작해야 반영됨 -> 컨피그맵 이름에 버전번호를 넣는 것은 좋은 방법

## 시크릿 인증 관리

디플로이먼트에 작성

컨피그맵을 사용하면 안될까 싶지만, 시크릿은 그 자체로 중요한 정보이며 응당 구성과는 다른 방식으로 액세스 제어, 처리, 업데이트를 할 수 있어야 한다.

시크릿 키 관리는 HashCorp Vault나 CSP 서비스.

시크릿은 볼륨(tmpfs) 램 기반의 파일 시스템으로 생성한 후 컨테이너에 마운트.

CSI 드라이버를 통해 외부에 위치한 KMS를 사용할 수 있음.

### 간단한 스테이트풀 데이터베이스 배포

StatefulSet 리소스를 사용하여 배포.

PVC로 PV를 가져옴. (Claim : 리소스를 달라는 요청)

***헤드리스 서비스*** : Cluster IP가 없는 서비스. 대신, 스테이트풀셋의 모든 파드에 대한 DNS 엔듵리를 가지고 있다.

## 헬름을 이용한 애플리케이션 파라미터화

처음에는 그냥 한 클러스터에서 다른 클러스터로 파일을 복사한다. 환경에 따라 간극(skew)가 더 벌어지게 된다.

브랜치, 버저닝 방식도 있지만 템플릿 시스템을 선택하게 됨.

많이 쓰는 구성을 기준으로 삼되, 그때 그때 필요에 따라 의도적으로 커스터마이징 -> Helm

Chart라는 여러 파일로 애플리케이션을 패키징.

# Chapter 02. 개발자 워크플로

**그러나 쿠버네티스로 서비스할 애플리케이션을 더 쉽게 개발할 수 있게 해주는 것은 아니다.**

개발 클러스터를 잘 구축해서 쿠버네티스용 애플리케이션 개발을 간소화하는 것은 쿠버네티스 시스템의 성공을 보장하는 핵심 요소다.

## 목표

온보딩 -> 개발 -> 테스팅

## 개발 클러스터 구축

단일 개발 클러스터는 비용 효율적이고 전사 공용 기능을 클러스터에 쉽게 추가할 수 있음. 단, 나중에 확장되면 수백명을 수용할 수 있는 클러스터보다는 팀이나 그룹 단위로 작은 클러스터를 두는 방안을 고려하는 것이 좋다.

유저, 네임스페이스를 추가하는 과정은 아직도 간단한 편은 아니기 때문에 온보딩 프로세스를 잘 준비해둬야 한다.

쿠버네티스의 리소스 관리 및 RBAC을 잘 활용하면 충돌 확률은 줄일 수 있으나, 여전히 먹통이 되거나 resource leak을 일으킬 수 있다.

## 여러 개발자가 사용할 공용 클러스터 구축

네임스페이스 : 유저 간의 간섭을 제거하는 가장 확실한 방법. RBAC 스코프도 네임스페이스로 제한 가능.

### 유저 온보딩

1. 인증서 기반 인증
2. 외부 identity 시스템(AWS IAM)을 통해 구성 : 일반적으로 권장. 수명이 긴 인증서보다는 수명이 짧은 토큰을 사용 + 아이덴티티 데이터를 따로 보관할 필요가 없음.

### 네임스페이스 생성과 보안

```bash
$ kubectl create namespace my-namespace
```

annotation 형태로 메타데이터를 네임스페이스에 추가. (Jinja 같은 템플릿을 활용해 YAML 만들고 붙임)

유저에게 namespace 권한 부여 -> RoleBinding 오브젝트 활용.

```bash
$ kubectl create -f role-binding.yaml
```

예산이 초과되지 않도록 네임스페이스 리소스의 사용량을 제한하거나 개발자에게 리소스를 공평하게 분배하고 싶다면 ResourceQuota 오브젝트를 사용한다.

ResourceQuota : 오브젝트 수 등으로 조절 가능. 전체 파드 리소스의 총합 같은 걸로 제어 가능 : https://kubernetes.io/ko/docs/concepts/policy/resource-quotas/

### 네임스페이스 관리

1. 온보딩 프로세스의 일부로 각 유저에게 고유 네임스페이스 발급
2. TTL 기반으로 임시 네임스페이스를 발급 : 메타데이터를 활용해 리소스 사용량을 추적하고 적시에 네임스페이스 삭제

**시간이 있고 의지가 있다면** 이렇게 네임스페이스를 선언으로 관리하고 RBAC를 활성화하는 구조가 바람직하다(CRD를 활용).

리소스 회수 시 ScheduledJob으로 주기적으로 회수할 수도 있음.

**LaaS** : Logging as a Service (ElasticSearch 등)

## 개발자 워크플로 활성화

안타깝게도 애플리케이션을 처음 작동시키는 것은 단순한 자동화 이상의 많은 절차를 요하는 작업이다.

### 초기 설치

완전한 애플리케이션을 빌드하려면 디펜던시를 모조리 찾아 배포해야 하는데, 부실하거나 제때 업데이트가 안 된 메뉴얼 때문에 시행착오를 겪는 일이 잦다. 

### 액티브한 개발 환경

개발자가 애플리케이션을 신속하게 이터레이션할 수 있는 환경을 제공해야 한다.

새 코드를 배포하는 가장 쉬운 방법은 이전 디플로이먼트 오브젝트를 삭제한 다음 새로 빌드한 이미지를 가리키는 디플로이먼트를 생성하는 것 => 업데이트하면 롤아웃이 트리거되기 때문에 환경 잘못 구분 시의 리스크 감소를 위하여.

### 테스트와 디버깅

kubectl과 친해지거나 익스텐션을 잘 활용하자!


d
