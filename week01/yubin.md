# 01. 기본 서비스 설치

### 예제 애플리케이션 - 간단한 저널 서비스
- NGINX static 파일 서버 + RESTful API + Redis DB 다중 계층 구조

### 구성 파일 관리
- 쿠버네티스는 선언형 방식으로 관리. 명령형 x.
- 명령형은 문제 이해/재현이 어려움
- JSON, YAML 사용 (YAML이 간결)
- 구성은 git으로 관리

## 디플로이먼트를 이용한 복제 서비스 생성

### 이미지 관리 모범 사례
- 이미지 빌드 프로세스는 공급망 공격에 취약
- 이미지 네이밍은 immutable tag 권장
- semantic version + SHA hash 조합 (ex. v1.0.1-bfeda01f)

### 애플리케이션 레플리카 생성
`replica`: 예기치 않은 크래시에 대비 / 애플리케이션의 새버전 중단없이 롤아웃하기 위해 2개 이상 권장  
`ReplicaSet`: 특정 버전 애플리케이션을 직접 복제하는 리소스  
하지만 코드 수정 → 모든 버전이 변경되므로 직접 사용보다 `Deployment` 권장  
`Deployment`: 복제 + 버저닝 + 단계적 롤아웃 지원 → 무중단 버전 전환 가능  

### 애플리케이션 디플로이먼트 리소스 관련 설명
- 모든 리소스에 `app: frontend` 레이블 → 디플로이먼트, 레플리카셋, 파드 구별 및 일괄 조회
- 주석은 협업/가독성 굿

### 리소스 요청 및 제한
- `requests`: 호스트에 예약된 리소스
- `limits`: 컨테이너가 사용할 수 있는 최대 리소스
- 두 값을 동일하게 설정하면 동작 예측 쉬움
- 하지만 효율성은 떨어짐 → 점차 분리 설정 필요

### CI/CD
- `kubectl apply -f deployment.yaml` 로 배포
- 소스 코드와 클러스터 상태를 일치시키는 것이 이상적
- `GitOps + CI/CD`로 특정 브랜치만 프로덕션 배포

## HTTP 트래픽을 처리하는 외부 인그레스 설치 

### 인그레스(ingress)를 통한 외부 노출
- 클러스터 리소스는 내부 전용 → 외부 노출 위해 Service & LoadBalancer 필요
- Service: TCP/UDP 트래픽 로드밸런싱
- Ingress: HTTP(S) 요청 기반 라우팅
- 단순 앱도 확장성 위해 Ingress 권장
- Ingress 한계 시 Gateway API 고려
- Ingress 리소스 정의하려면 Ingress Controller 필요
- 클라우드 제공 기본 컨트롤러 or 오픈소스(Nginx, HAProxy)
- 오픈소스 컨트롤러는 헬름으로 설치/관리 추천

### 컨피그맵으로 애플리케이션 구성
- 애플리케이션 기능/환경별 설정은 코드와 분리하는 게 바람직
- 같은 바이너리도 지역·환경 따라 다른 구성 필요 → 민첩성 확보
- 구성 파일로 기능 제어 가능 → 무중단 롤아웃/롤백 지원
- `ConfigMap`: 쿠버네티스에서 구성 관리 리소스
- 파드에 파일 또는 환경 변수 형태로 전달 가능
- ConfigMap 수정만으론 기존 파드 자동 갱신 x → 재시작 필요
- 버전 네이밍(frontend-config-v1, v2...)으로 관리
- 새 버전은 디플로이먼트 갱신 시 자동 롤아웃
- 롤백도 쉬움 (이전 버전 ConfigMap 그대로 존재)

### 시크릿 인증 관리
- 시크릿은 설정과 달리 접근 제어, 처리, 갱신에 사용
- 쿠버네티스는 시크릿 데이터를 다룰 수 있는 리소스 제공
- 기본적으로 시크릿은 암호화되지 않은 상태로 저장됨
- 시크릿은 볼륨을 통해 애플리케이션과 결합
- tmpfs(램 기반 파일시스템) 볼륨을 컨테이너에 마운트 → 물리적 피해에도 시크릿 노출 방지

### 간단한 스테이트풀 데이터베이스 배포
- 쿠버네티스에서는 파드가 재스케줄링될 수 있음 → 데이터가 컨테이너/노드에 있으면 손실 위험
- `PersistentVolume(PV)` 사용해 데이터 보존 (원격 스토리지 기반)
- `StatefulSet` 사용해 배포 → 강한 일관성 보장
- 싱글턴 배포는 영향 적음, 상태 복제 배포 시 유용
- Redis는 `PersistentVolumeClaim`으로 PV를 할당받음
- 템플릿으로 복제 시 각 파드는 고유한 PV를 가짐
- 헤드리스 서비스 : Cluster IP가 없지만 스테이트풀셋의 모든 파드에 대한 DNS 엔트리를 가짐

### 서비스를 응용한 TCP 로드 밸런서 구축
읽기 요청: 모든 StatefulSet 레플리카가 데이터 복제 → 어디서든 처리 가능  
쓰기 요청: 반드시 Redis 마스터에서 처리  
- 쓰기 전용 파드에 접근하기 위해 `Headless Service` 사용 (클러스터 IP 없음)
- StatefulSet 파드별 DNS 설정 → 클라이언트가 직접 쓰기 서버에 연결해야 함

### 인그레스를 이용해 트래픽을 스태틱 파일 서버로 전달
- Nginx 컨테이너 기반 스태틱 이미지 서버 구축
- Ingress 통해 각 레플리카에 배포된 정적 파일 서버로 트래픽 전달

### 헬름을 이용한 애플리케이션 파라미터화
- 모든 파일을 동기화 상태로 유지해야 함 → 브랜치와 버전 관리 필요

템플릿 시스템: 애플리케이션 설정의 뼈대(템플릿) + 환경별 파라미터 결합 (ex. Helm Chart)

### 서비스 배포 모범 사례
- 대부분의 서비스는 디플로이먼트 리소스로 배포
- Deployment → Service(로드밸런서)로 노출
- HTTP 애플리케이션은 Ingress 컨트롤러 통해 노출 가능 (라우팅, SSL 지원)
- 여러 환경에서 재사용하려면 애플리케이션 파라미터화 필수


# 2. 개발자 워크플로

### 개발 클러스터 구축
- 대규모 단일 개발 클러스터가 개인 클러스터보다 효율적
- 개발자 간 충돌은 리소스 관리 및 RBAC 활용하여 관리 가능 (but resource leak 생길수도 있음)

### 여러 개발자가 사용할 공용 클러스터 구축
네임스페이스로 리소스 범위를 분리 → 다른 사용자의 리소스에 영향 방지

#### 유저 온보딩
- 쿠버네티스 접근은 증명 기반 인증 사용
- kubeconfig 파일을 생성해 사용자에게 전달
- 외부 신원 시스템 연동 시 중앙 관리 가능 (ex. AWS IAM 기반 클러스터 접근)

#### 네임스페이스 생성과 보안
- annotation 기반으로 네임스페이스 관리
- 사용자에게 RoleBinding 부여
- 시크릿 리소스 접근 권한은 주의 필요
- 리소스 사용량 제한은 `ResourceQuota`로 설정

#### 네임스페이스 관리
네임스페이스 할당 방식
- 개발자에게 직접 할당 → 가비지 컬렉션 어려움  
- TTL 기반 임시 네임스페이스 → 자동 삭제 가능  

만료된 네임스페이스는 스크립트로 정리  
kubectl + CRD 활용해 네임스페이스 생성·할당 자동화  
RBAC으로 선언적 관리 가능  

#### 클러스터 수준 서비스
클러스터 단위 서비스 = LaaS(Logging as a service) 형태  
- `kubectl logs`로 로그 접근 가능 (단, 길이 제한, 검색 불가. 그래서 앨라스틱서치 같은거 사용 하면 편함)

### 개발자 워크플로 활성화
온보딩 완료 → 이제 개발자가 애플리게이션 개발에 착수하도록 유도  
- 애플리케이션의 디펜던시를 설치하는 스크립트처럼 작성해서 모든 환경에서도 작업하도록 설정
- CI/CD에 통합해두면 간편

### 개발 환경 설정 모범 사례
- 개발 경험을 온보딩 → 개발 → 테스팅 단계로 구분
- 대규모 단일 클러스터가 더 효율적
- 새 사용자 추가 시 네임스페이스 기반 접근 제한 + 리소스 제한
- 스크립트로 네임스페이스 정리 자동화
- 로그/모니터링 같은 클러스터 단위 서비스 고려